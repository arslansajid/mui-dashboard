"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("proxy-state-tree");
const overmind_1 = require("overmind");
const react = require("react");
const IS_PRODUCTION = process.env.NODE_ENV === 'production';
const IS_TEST = process.env.NODE_ENV === 'test';
const isNode = !IS_TEST && process && process.title && process.title.includes('node');
function throwMissingContextError() {
    throw new Error('The Overmind hook could not find an Overmind instance on the context of React. Please make sure you use the Provider component at the top of your application and expose the Overmind instance there. Please read more in the React guide on the website');
}
const context = react.createContext({});
let nextComponentId = 0;
exports.Provider = context.Provider;
exports.createHook = () => {
    let currentComponentInstanceId = 0;
    const { ReactCurrentOwner, } = react.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    const useCurrentComponent = () => {
        return ReactCurrentOwner &&
            ReactCurrentOwner.current &&
            ReactCurrentOwner.current.elementType
            ? ReactCurrentOwner.current.elementType
            : {};
    };
    const useForceRerender = () => {
        const [flushId, setState] = react.useState(() => -1);
        // We use memo here, instead of ref, to support fast-refresh
        const mountedRef = react.useMemo(() => ({ current: true }), []);
        react.useEffect(() => () => {
            mountedRef.current = false;
        }, []);
        const forceRerender = (_, __, flushId) => {
            if (mountedRef.current) {
                setState(flushId);
            }
        };
        return {
            forceRerender,
            flushId,
        };
    };
    return () => {
        const overmind = react.useContext(context);
        if (!overmind.mode) {
            throwMissingContextError();
        }
        if (isNode || overmind.mode.mode === overmind_1.MODE_SSR) {
            return {
                state: overmind.state,
                actions: overmind.actions,
                effects: overmind.effects,
                addMutationListener: overmind.addMutationListener,
                reaction: overmind.reaction,
            };
        }
        const tree = react.useMemo(() => overmind.proxyStateTree.getTrackStateTree(), []);
        if (IS_PRODUCTION) {
            const { forceRerender } = useForceRerender();
            react.useEffect(() => () => {
                ;
                overmind.proxyStateTree.disposeTree(tree);
            }, []);
            react.useLayoutEffect(() => tree.stopTracking());
            tree.track(forceRerender);
        }
        else {
            const component = useCurrentComponent();
            const name = component.name;
            component.__componentId =
                typeof component.__componentId === 'undefined'
                    ? nextComponentId++
                    : component.__componentId;
            const { current: componentInstanceId } = react.useRef(currentComponentInstanceId++);
            const { flushId, forceRerender } = useForceRerender();
            react.useLayoutEffect(() => {
                overmind.eventHub.emitAsync(overmind_1.EventType.COMPONENT_ADD, {
                    componentId: component.__componentId,
                    componentInstanceId,
                    name,
                    paths: Array.from(tree.pathDependencies),
                });
                return () => {
                    ;
                    overmind.proxyStateTree.disposeTree(tree);
                    overmind.eventHub.emitAsync(overmind_1.EventType.COMPONENT_REMOVE, {
                        componentId: component.__componentId,
                        componentInstanceId,
                        name,
                    });
                };
            }, []);
            react.useLayoutEffect(() => {
                tree.stopTracking();
                overmind.eventHub.emitAsync(overmind_1.EventType.COMPONENT_UPDATE, {
                    componentId: component.__componentId,
                    componentInstanceId,
                    name,
                    flushId,
                    paths: Array.from(tree.pathDependencies),
                });
            });
            tree.track(forceRerender);
        }
        const suspend = (cb) => {
            const value = cb();
            if (value === null || value === undefined) {
                ;
                overmind.proxyStateTree.disposeTree(tree);
                throw new Promise((resolve) => {
                    const dispose = overmind.addFlushListener(() => {
                        const newValue = cb();
                        if (newValue === null || newValue === undefined) {
                            return;
                        }
                        dispose();
                        resolve();
                    });
                });
            }
            return value;
        };
        return {
            state: tree.state,
            actions: overmind.actions,
            effects: overmind.effects,
            addMutationListener: overmind.addMutationListener,
            reaction: overmind.reaction,
            suspend,
        };
    };
};
exports.createConnect = () => {
    return (component) => {
        let componentInstanceId = 0;
        const name = component.name;
        const populatedComponent = component;
        populatedComponent.__componentId =
            typeof populatedComponent.__componentId === 'undefined'
                ? nextComponentId++
                : populatedComponent.__componentId;
        const isClassComponent = component.prototype && typeof component.prototype.render === 'function';
        if (isClassComponent) {
            const originalRender = component.prototype.render;
            component.prototype.render = function () {
                if (this.props.overmind) {
                    return this.props.overmind.tree.trackScope(() => originalRender.call(this), this.props.overmind.onUpdate);
                }
                return originalRender.call(this);
            };
        }
        if (IS_PRODUCTION) {
            class HOC extends react.Component {
                constructor(props, context) {
                    super(props);
                    this.onUpdate = () => {
                        this.setState({
                            overmind: {
                                state: this.tree.state,
                                effects: this.overmind.effects,
                                actions: this.overmind.actions,
                                addMutationListener: this.overmind.addMutationListener,
                                onUpdate: this.onUpdate,
                                tree: this.tree,
                                reaction: this.overmind.reaction,
                            },
                        });
                    };
                    if (!context) {
                        throwMissingContextError();
                    }
                    this.overmind = context;
                    this.tree = this.overmind.proxyStateTree.getTrackStateTree();
                    this.state = {
                        overmind: {
                            state: this.tree.state,
                            effects: this.overmind.effects,
                            actions: this.overmind.actions,
                            addMutationListener: this.overmind.addMutationListener,
                            onUpdate: this.onUpdate,
                            tree: this.tree,
                            reaction: this.overmind.reaction,
                        },
                    };
                    this.wrappedComponent = (...args) => this.tree.trackScope(() => component(...args), this.onUpdate);
                }
                componentWillUnmount() {
                    this.overmind.proxyStateTree.disposeTree(this.tree);
                }
                render() {
                    if (isClassComponent) {
                        return react.createElement(component, Object.assign(Object.assign({}, this.props), { overmind: this.state.overmind }));
                    }
                    return react.createElement(this.wrappedComponent, Object.assign(Object.assign({}, this.props), { overmind: this.state.overmind }));
                }
            }
            HOC.contextType = context;
            return HOC;
        }
        else {
            class HOC extends react.Component {
                constructor(props, context) {
                    super(props);
                    this.componentInstanceId = componentInstanceId++;
                    this.currentFlushId = 0;
                    this.onUpdate = (mutatons, paths, flushId) => {
                        this.currentFlushId = flushId;
                        this.isUpdating = true;
                        this.setState({
                            overmind: {
                                state: this.tree.state,
                                effects: this.overmind.effects,
                                actions: this.overmind.actions,
                                addMutationListener: this.overmind.addMutationListener,
                                onUpdate: this.onUpdate,
                                tree: this.tree,
                                reaction: this.overmind.reaction,
                            },
                        });
                    };
                    if (!context) {
                        throwMissingContextError();
                    }
                    this.overmind = context;
                    this.tree = this.overmind.proxyStateTree.getTrackStateTree();
                    this.state = {
                        overmind: {
                            state: this.tree.state,
                            effects: this.overmind.effects,
                            actions: this.overmind.actions,
                            addMutationListener: this.overmind.addMutationListener,
                            onUpdate: this.onUpdate,
                            tree: this.tree,
                            reaction: this.overmind.reaction,
                        },
                    };
                    this.wrappedComponent = (...args) => this.tree.trackScope(() => component(...args), this.onUpdate);
                }
                componentDidMount() {
                    this.overmind.eventHub.emitAsync(overmind_1.EventType.COMPONENT_ADD, {
                        componentId: populatedComponent.__componentId,
                        componentInstanceId: this.componentInstanceId,
                        name,
                        paths: Array.from(this.tree.pathDependencies),
                    });
                }
                componentDidUpdate() {
                    if (this.isUpdating) {
                        this.overmind.eventHub.emitAsync(overmind_1.EventType.COMPONENT_UPDATE, {
                            componentId: populatedComponent.__componentId,
                            componentInstanceId: this.componentInstanceId,
                            name,
                            flushId: this.currentFlushId,
                            paths: Array.from(this.tree.pathDependencies),
                        });
                        this.isUpdating = false;
                    }
                }
                componentWillUnmount() {
                    this.overmind.proxyStateTree.disposeTree(this.tree);
                    this.overmind.eventHub.emitAsync(overmind_1.EventType.COMPONENT_REMOVE, {
                        componentId: populatedComponent.__componentId,
                        componentInstanceId: this.componentInstanceId,
                        name,
                    });
                }
                render() {
                    if (isClassComponent) {
                        return react.createElement(component, Object.assign(Object.assign({}, this.props), { overmind: this.state.overmind }));
                    }
                    return react.createElement(this.wrappedComponent, Object.assign(Object.assign({}, this.props), { overmind: this.state.overmind }));
                }
            }
            HOC.contextType = context;
            Object.defineProperties(HOC, {
                name: {
                    value: 'Connect' + (component.displayName || component.name || ''),
                },
            });
            return HOC;
        }
    };
};
//# sourceMappingURL=index.js.map