{"ast":null,"code":"import { IS_PROXY, TrackStateTree } from 'proxy-state-tree';\nimport { EventType } from './internalTypes';\nexport const IS_DERIVED = Symbol('IS_DERIVED');\nexport class Derived {\n  constructor(cb) {\n    this.cb = cb;\n    this.isDirty = true;\n    this.updateCount = 0;\n    const boundEvaluate = this.evaluate.bind(this);\n\n    if (process.env.NODE_ENV === 'development') {\n      boundEvaluate.dispose = () => {\n        this.disposeOnMutation();\n      };\n    }\n\n    boundEvaluate[IS_DERIVED] = true;\n    return boundEvaluate;\n  }\n\n  runScope(tree, path) {\n    const parent = path.slice(0, path.length - 1).reduce((curr, key) => curr[key], tree.state);\n    return this.cb(parent, tree.state);\n  }\n\n  evaluate(eventHub, tree, proxyStateTree, path) {\n    if (!this.disposeOnMutation) {\n      this.disposeOnMutation = proxyStateTree.onMutation((_, paths, flushId) => {\n        if (typeof path.reduce((aggr, key) => aggr && aggr[key], proxyStateTree.sourceState) !== 'function') {\n          this.disposeOnMutation();\n          return;\n        }\n\n        if (this.isDirty) {\n          return;\n        }\n\n        for (let mutationPath of paths) {\n          if (this.paths.has(mutationPath)) {\n            this.isDirty = true;\n            eventHub.emitAsync(EventType.DERIVED_DIRTY, {\n              derivedPath: path,\n              path: mutationPath,\n              flushId\n            });\n            return;\n          }\n        }\n      });\n    } // During development we need to move the ownership of whatever state is returned from\n    // the derived to track it correctly. In production we only have one proxifier, so no worries\n\n\n    if (this.isDirty || this.previousProxifier !== tree.proxifier) {\n      const getPaths = tree.trackPaths();\n      this.value = this.runScope(tree, path);\n      this.isDirty = false;\n      this.paths = getPaths();\n\n      if (process.env.NODE_ENV === 'development') {\n        eventHub.emitAsync(EventType.DERIVED, {\n          path,\n          paths: Array.from(this.paths),\n          updateCount: this.updateCount,\n          value: this.value\n        });\n        this.updateCount++;\n      }\n    }\n\n    if (tree instanceof TrackStateTree) {\n      // If we access a cached value we have to make sure that we move\n      // the tracked paths into the tree looking at it, where\n      // addTrackingPath is for initial tree and \"trackPathListeners\"\n      // is for nested derived\n      for (let path of this.paths) {\n        tree.addTrackingPath(path);\n        tree.trackPathListeners.forEach(cb => cb(path));\n      }\n    }\n\n    this.previousProxifier = tree.proxifier; // This value might be a proxy, we need to rescope\n    // it to the current tree looking\n\n    if (this.value && this.value[IS_PROXY]) {\n      return proxyStateTree.rescope(this.value, tree);\n    }\n\n    return this.value;\n  }\n\n}","map":{"version":3,"sources":["../src/derived.ts"],"names":[],"mappings":"AACA,SAEE,QAFF,EAKE,cALF,QAMO,kBANP;AAQA,SAAS,SAAT,QAAkC,iBAAlC;AAEA,OAAO,MAAM,UAAU,GAAG,MAAM,CAAC,YAAD,CAAzB;AAEP,OAAM,MAAO,OAAP,CAAc;AAOlB,EAAA,WAAA,CAAoB,EAApB,EAA+D;AAA3C,SAAA,EAAA,GAAA,EAAA;AANZ,SAAA,OAAA,GAAmB,IAAnB;AAIA,SAAA,WAAA,GAAsB,CAAtB;AAGN,UAAM,aAAa,GAAQ,KAAK,QAAL,CAAc,IAAd,CAAmB,IAAnB,CAA3B;;AAEA,QAAI,OAAO,CAAC,GAAR,CAAY,QAAZ,KAAyB,aAA7B,EAA4C;AAC1C,MAAA,aAAa,CAAC,OAAd,GAAwB,MAAK;AAC3B,aAAK,iBAAL;AACD,OAFD;AAGD;;AAED,IAAA,aAAa,CAAC,UAAD,CAAb,GAA4B,IAA5B;AAEA,WAAO,aAAP;AACD;;AACO,EAAA,QAAQ,CAAC,IAAD,EAAO,IAAP,EAAW;AACzB,UAAM,MAAM,GAAG,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,IAAI,CAAC,MAAL,GAAc,CAA5B,EAA+B,MAA/B,CAAsC,CAAC,IAAD,EAAO,GAAP,KAAe,IAAI,CAAC,GAAD,CAAzD,EAAgE,IAAI,CAAC,KAArE,CAAf;AAEA,WAAO,KAAK,EAAL,CAAQ,MAAR,EAAgB,IAAI,CAAC,KAArB,CAAP;AACD;;AACD,EAAA,QAAQ,CACN,QADM,EAEN,IAFM,EAGN,cAHM,EAIN,IAJM,EAIF;AAEJ,QAAI,CAAC,KAAK,iBAAV,EAA6B;AAC3B,WAAK,iBAAL,GAAyB,cAAc,CAAC,UAAf,CACvB,CAAC,CAAD,EAAI,KAAJ,EAAW,OAAX,KAAsB;AACpB,YAAI,OAAO,IAAI,CAAC,MAAL,CAAY,CAAC,IAAD,EAAO,GAAP,KAAe,IAAI,IAAI,IAAI,CAAC,GAAD,CAAvC,EAA8C,cAAc,CAAC,WAA7D,CAAP,KAAqF,UAAzF,EAAqG;AACnG,eAAK,iBAAL;AACA;AACD;;AAED,YAAI,KAAK,OAAT,EAAkB;AAChB;AACD;;AAED,aAAK,IAAI,YAAT,IAAyB,KAAzB,EAAgC;AAC9B,cAAI,KAAK,KAAL,CAAW,GAAX,CAAe,YAAf,CAAJ,EAAkC;AAChC,iBAAK,OAAL,GAAe,IAAf;AACA,YAAA,QAAQ,CAAC,SAAT,CAAmB,SAAS,CAAC,aAA7B,EAA4C;AAC1C,cAAA,WAAW,EAAE,IAD6B;AAE1C,cAAA,IAAI,EAAE,YAFoC;AAG1C,cAAA;AAH0C,aAA5C;AAKA;AACD;AACF;AACF,OAtBsB,CAAzB;AAwBD,KA3BG,CA6BJ;AACA;;;AACA,QAAI,KAAK,OAAL,IAAgB,KAAK,iBAAL,KAA2B,IAAI,CAAC,SAApD,EAA+D;AAC7D,YAAM,QAAQ,GAAG,IAAI,CAAC,UAAL,EAAjB;AAEA,WAAK,KAAL,GAAa,KAAK,QAAL,CAAc,IAAd,EAAoB,IAApB,CAAb;AACA,WAAK,OAAL,GAAe,KAAf;AACA,WAAK,KAAL,GAAa,QAAQ,EAArB;;AAEA,UAAI,OAAO,CAAC,GAAR,CAAY,QAAZ,KAAyB,aAA7B,EAA4C;AAC1C,QAAA,QAAQ,CAAC,SAAT,CAAmB,SAAS,CAAC,OAA7B,EAAsC;AACpC,UAAA,IADoC;AAEpC,UAAA,KAAK,EAAE,KAAK,CAAC,IAAN,CAAW,KAAK,KAAhB,CAF6B;AAGpC,UAAA,WAAW,EAAE,KAAK,WAHkB;AAIpC,UAAA,KAAK,EAAE,KAAK;AAJwB,SAAtC;AAMA,aAAK,WAAL;AACD;AACF;;AAED,QAAI,IAAI,YAAY,cAApB,EAAoC;AAClC;AACA;AACA;AACA;AACA,WAAK,IAAI,IAAT,IAAiB,KAAK,KAAtB,EAA6B;AAC3B,QAAA,IAAI,CAAC,eAAL,CAAqB,IAArB;AACA,QAAA,IAAI,CAAC,kBAAL,CAAwB,OAAxB,CAAiC,EAAD,IAAQ,EAAE,CAAC,IAAD,CAA1C;AACD;AACF;;AAED,SAAK,iBAAL,GAAyB,IAAI,CAAC,SAA9B,CA5DI,CA8DJ;AACA;;AACA,QAAI,KAAK,KAAL,IAAc,KAAK,KAAL,CAAW,QAAX,CAAlB,EAAwC;AACtC,aAAO,cAAc,CAAC,OAAf,CAAuB,KAAK,KAA5B,EAAmC,IAAnC,CAAP;AACD;;AAED,WAAO,KAAK,KAAZ;AACD;;AAlGiB","sourcesContent":["import { EventEmitter } from 'betsy'\nimport {\n  IMutationTree,\n  IS_PROXY,\n  ITrackStateTree,\n  ProxyStateTree,\n  TrackStateTree,\n} from 'proxy-state-tree'\n\nimport { EventType, Events } from './internalTypes'\n\nexport const IS_DERIVED = Symbol('IS_DERIVED')\n\nexport class Derived {\n  private isDirty: boolean = true\n  private previousProxifier: any\n  private value: any\n  private paths: Set<string>\n  private updateCount: number = 0\n  private disposeOnMutation: () => void\n  constructor(private cb: (state: object, parent: object) => void) {\n    const boundEvaluate: any = this.evaluate.bind(this)\n\n    if (process.env.NODE_ENV === 'development') {\n      boundEvaluate.dispose = () => {\n        this.disposeOnMutation()\n      }\n    }\n\n    boundEvaluate[IS_DERIVED] = true\n\n    return boundEvaluate\n  }\n  private runScope(tree, path) {\n    const parent = path.slice(0, path.length - 1).reduce((curr, key) => curr[key], tree.state)\n\n    return this.cb(parent, tree.state)\n  }\n  evaluate(\n    eventHub: EventEmitter<Events>,\n    tree: ITrackStateTree<any> | IMutationTree<any>,\n    proxyStateTree: ProxyStateTree<any>,\n    path\n  ) {\n    if (!this.disposeOnMutation) {\n      this.disposeOnMutation = proxyStateTree.onMutation(\n        (_, paths, flushId) => {\n          if (typeof path.reduce((aggr, key) => aggr && aggr[key], proxyStateTree.sourceState) !== 'function') {\n            this.disposeOnMutation()\n            return\n          }\n          \n          if (this.isDirty) {\n            return\n          }\n\n          for (let mutationPath of paths) {\n            if (this.paths.has(mutationPath)) {\n              this.isDirty = true\n              eventHub.emitAsync(EventType.DERIVED_DIRTY, {\n                derivedPath: path,\n                path: mutationPath,\n                flushId,\n              })\n              return\n            }\n          }\n        }\n      )\n    }\n\n    // During development we need to move the ownership of whatever state is returned from\n    // the derived to track it correctly. In production we only have one proxifier, so no worries\n    if (this.isDirty || this.previousProxifier !== tree.proxifier) {\n      const getPaths = tree.trackPaths()\n\n      this.value = this.runScope(tree, path)\n      this.isDirty = false\n      this.paths = getPaths()\n\n      if (process.env.NODE_ENV === 'development') {\n        eventHub.emitAsync(EventType.DERIVED, {\n          path,\n          paths: Array.from(this.paths),\n          updateCount: this.updateCount,\n          value: this.value,\n        })\n        this.updateCount++\n      }\n    }\n\n    if (tree instanceof TrackStateTree) {\n      // If we access a cached value we have to make sure that we move\n      // the tracked paths into the tree looking at it, where\n      // addTrackingPath is for initial tree and \"trackPathListeners\"\n      // is for nested derived\n      for (let path of this.paths) {\n        tree.addTrackingPath(path)\n        tree.trackPathListeners.forEach((cb) => cb(path))\n      }\n    }\n\n    this.previousProxifier = tree.proxifier\n\n    // This value might be a proxy, we need to rescope\n    // it to the current tree looking\n    if (this.value && this.value[IS_PROXY]) {\n      return proxyStateTree.rescope(this.value, tree)\n    }\n\n    return this.value\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}