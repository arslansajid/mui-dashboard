{"ast":null,"code":"import { EventEmitter } from 'betsy';\nimport isPlainObject from 'is-plain-obj';\nimport { IS_PROXY, PATH, ProxyStateTree, VALUE } from 'proxy-state-tree';\nimport { Derived, IS_DERIVED } from './derived';\nimport { Devtools } from './Devtools';\nimport { EventType } from './internalTypes';\nimport { createContext, createMutationOperator, createNextPath, createOperator, operatorStarted, operatorStopped } from './operator';\nimport { proxifyEffects } from './proxyfyEffects';\nimport { EXECUTION, IS_OPERATOR, IS_TEST, MODE_DEFAULT, MODE_SSR, MODE_TEST, MockedEventEmitter, createActionsProxy, deepCopy, getActionPaths, getFunctionName, isPromise, mergeState, processState } from './utils';\nexport * from './types';\nexport { createOperator, createMutationOperator };\nexport { MODE_DEFAULT, MODE_TEST, MODE_SSR } from './utils';\nexport { SERIALIZE, rehydrate } from './rehydrate';\nexport { statemachine } from './statemachine';\nexport const derived = cb => cb;\nexport { json } from './utils';\nexport function createOvermindSSR(config) {\n  const ssr = new Overmind(config, {\n    devtools: false\n  }, {\n    mode: MODE_SSR\n  });\n  const mutationTree = ssr.proxyStateTree.getMutationTree();\n  ssr.state = mutationTree.state;\n\n  ssr.hydrate = () => {\n    return mutationTree.flush().mutations;\n  };\n\n  return ssr;\n}\nexport function createOvermindMock(config, mockedEffects) {\n  const mock = new Overmind(Object.assign({}, config, {\n    state: deepCopy(config.state)\n  }), {\n    devtools: false\n  }, {\n    mode: MODE_TEST,\n    options: {\n      effectsCallback: effect => {\n        const mockedEffect = (effect.name ? effect.name.split('.') : []).reduce((aggr, key) => aggr ? aggr[key] : aggr, mockedEffects);\n\n        if (!mockedEffect || mockedEffect && !mockedEffect[effect.method]) {\n          throw new Error(`The effect \"${effect.name}\" with method ${effect.method} has not been mocked`);\n        }\n\n        return mockedEffect[effect.method](...effect.args);\n      }\n    }\n  });\n  const action = mock.createAction('onInitialize', config.onInitialize);\n\n  mock.onInitialize = () => action(mock);\n\n  mock.mutations = [];\n  return mock;\n}\nexport function createOvermind(config, options) {\n  return new Overmind(config, options, {\n    mode: MODE_DEFAULT\n  });\n}\nconst hotReloadingCache = {}; // We do not use IConfig<Config> directly to type the class in order to avoid\n// the 'import(...)' function to be used in exported types.\n\nexport class Overmind {\n  constructor(configuration, options = {}, mode = {\n    mode: MODE_DEFAULT\n  }) {\n    this.actionReferences = [];\n    this.nextExecutionId = 0;\n\n    this.reaction = (stateCallback, updateCallback, options = {}) => {\n      let disposer;\n\n      if (options.nested) {\n        const value = stateCallback(this.state);\n\n        if (!value || !value[IS_PROXY]) {\n          throw new Error('You have to return an object or array from the Overmind state when using a \"nested\" reaction');\n        }\n\n        const path = value[PATH];\n        disposer = this.addFlushListener(mutations => {\n          mutations.forEach(mutation => {\n            if (mutation.path.startsWith(path)) {\n              updateCallback(path.split(this.delimiter).reduce((aggr, key) => aggr[key], this.state));\n            }\n          });\n        });\n      } else {\n        const tree = this.proxyStateTree.getTrackStateTree();\n        let returnValue;\n\n        const updateReaction = () => {\n          tree.trackScope(() => returnValue = stateCallback(tree.state), () => {\n            updateReaction();\n            updateCallback(returnValue);\n          });\n        };\n\n        updateReaction();\n\n        disposer = () => {\n          tree.dispose();\n        };\n      }\n\n      if (options.immediate) {\n        updateCallback(stateCallback(this.state));\n      }\n\n      return disposer;\n    };\n\n    this.addMutationListener = cb => {\n      return this.proxyStateTree.onMutation(cb);\n    };\n\n    this.addFlushListener = cb => {\n      return this.proxyStateTree.onFlush(cb);\n    };\n\n    const name = options.name || 'OvermindApp';\n    this.delimiter = options.delimiter || '.';\n\n    if ((!process.env.NODE_ENV || process.env.NODE_ENV === 'development') && mode.mode === MODE_DEFAULT && options.hotReloading !== false && !(process && process.title && process.title.includes('node'))) {\n      if (hotReloadingCache[name]) {\n        return hotReloadingCache[name].reconfigure(configuration);\n      } else {\n        hotReloadingCache[name] = this;\n      }\n    }\n    /*\n      Set up an eventHub to trigger information from derived, computed and reactions\n    */\n\n\n    const eventHub = mode.mode === MODE_SSR ? new MockedEventEmitter() : new EventEmitter();\n    /*\n      Create the proxy state tree instance with the state and a wrapper to expose\n      the eventHub\n    */\n\n    const proxyStateTree = this.createProxyStateTree(configuration, eventHub, mode.mode === MODE_SSR ? false : process.env.NODE_ENV === 'development');\n    this.originalConfiguration = configuration;\n    this.state = proxyStateTree.state;\n    this.effects = configuration.effects || {};\n    this.proxyStateTree = proxyStateTree;\n    this.eventHub = eventHub;\n    this.mode = mode;\n    /*\n      Expose the created actions\n    */\n\n    this.actions = this.getActions(configuration.actions);\n\n    if (mode.mode === MODE_SSR) {\n      return;\n    }\n\n    if (process.env.NODE_ENV === 'development' && mode.mode === MODE_DEFAULT && typeof window !== 'undefined') {\n      let warning = 'OVERMIND: You are running in DEVELOPMENT mode.';\n\n      if (options.logProxies !== true) {\n        const originalConsoleLog = console.log;\n\n        console.log = (...args) => originalConsoleLog.apply(console, args.map(arg => arg && arg[IS_PROXY] ? arg[VALUE] : arg));\n\n        warning += '\\n\\n - To improve debugging experience \"console.log\" will NOT log proxies from Overmind, but the actual value. Please see docs to turn off this behaviour';\n      }\n\n      if (options.devtools || typeof location !== 'undefined' && location.hostname === 'localhost' && options.devtools !== false) {\n        const host = options.devtools === true ? 'localhost:3031' : options.devtools;\n        const name = options.name ? options.name : typeof document === 'undefined' ? 'NoName' : document.title || 'NoName';\n        this.initializeDevtools(host, name, eventHub, proxyStateTree.sourceState, configuration.actions);\n      } else {\n        warning += '\\n\\n - You are not running on localhost. You will have to manually define the devtools option to connect';\n      }\n\n      if (!IS_TEST) {\n        console.warn(warning);\n      }\n    }\n\n    if (process.env.NODE_ENV === 'production' && mode.mode === MODE_DEFAULT) {\n      eventHub.on(EventType.OPERATOR_ASYNC, () => {\n        proxyStateTree.getMutationTree().flush(true);\n      });\n      eventHub.on(EventType.ACTION_END, execution => {\n        if (!execution.parentExecution || !execution.parentExecution.isRunning) proxyStateTree.getMutationTree().flush();\n      });\n      let nextTick;\n\n      const flushTree = () => {\n        proxyStateTree.getMutationTree().flush(true);\n      };\n\n      this.proxyStateTree.onMutation(() => {\n        nextTick && clearTimeout(nextTick);\n        nextTick = setTimeout(flushTree, 0);\n      });\n    } else if (mode.mode === MODE_DEFAULT || mode.mode === MODE_TEST) {\n      eventHub.on(EventType.OPERATOR_ASYNC, execution => {\n        const flushData = execution.flush(true);\n\n        if (this.devtools && flushData.mutations.length) {\n          this.devtools.send({\n            type: 'flush',\n            data: Object.assign(Object.assign({}, execution), flushData)\n          });\n        }\n      });\n      eventHub.on(EventType.ACTION_END, execution => {\n        if (!execution.parentExecution || !execution.parentExecution.isRunning) {\n          const flushData = execution.flush();\n\n          if (this.devtools && flushData.mutations.length) {\n            this.devtools.send({\n              type: 'flush',\n              data: Object.assign(Object.assign({}, execution), flushData)\n            });\n          }\n        }\n      });\n    }\n\n    if (mode.mode === MODE_DEFAULT && configuration.onInitialize) {\n      const onInitialize = this.createAction('onInitialize', configuration.onInitialize);\n      this.initialized = Promise.resolve(onInitialize(this));\n    } else {\n      this.initialized = Promise.resolve(null);\n    }\n  }\n\n  createProxyStateTree(configuration, eventHub, devmode) {\n    const proxyStateTree = new ProxyStateTree(this.getState(configuration), {\n      devmode,\n      delimiter: this.delimiter,\n      onFunction: (tree, path, func) => {\n        if (func[IS_DERIVED]) {\n          return {\n            func,\n            value: func(eventHub, tree, proxyStateTree, path.split(this.delimiter))\n          };\n        }\n\n        const derived = new Derived(func);\n        return {\n          func: derived,\n          value: derived(eventHub, tree, proxyStateTree, path.split(this.delimiter))\n        };\n      },\n      onGetter: devmode ? (path, value) => {\n        this.eventHub.emitAsync(EventType.GETTER, {\n          path,\n          value\n        });\n      } : undefined\n    });\n    return proxyStateTree;\n  }\n\n  createExecution(name, action, parentExecution) {\n    const namespacePath = name.split('.');\n    namespacePath.pop();\n\n    if (process.env.NODE_ENV === 'production') {\n      return {\n        [EXECUTION]: true,\n        parentExecution,\n        namespacePath,\n        actionName: name,\n        getMutationTree: () => {\n          return this.proxyStateTree.getMutationTree();\n        },\n        getTrackStateTree: () => {\n          return this.proxyStateTree.getTrackStateTree();\n        },\n        emit: this.eventHub.emit.bind(this.eventHub)\n      };\n    }\n\n    const mutationTrees = [];\n    const execution = {\n      [EXECUTION]: true,\n      namespacePath,\n      actionId: this.actionReferences.indexOf(action),\n      executionId: this.nextExecutionId++,\n      actionName: name,\n      operatorId: 0,\n      isRunning: true,\n      parentExecution,\n      path: [],\n      emit: this.eventHub.emit.bind(this.eventHub),\n      send: this.devtools ? this.devtools.send.bind(this.devtools) : () => {},\n      trackEffects: this.trackEffects.bind(this, this.effects),\n      getNextOperatorId: (() => {\n        let currentOperatorId = 0;\n        return () => ++currentOperatorId;\n      })(),\n      flush: parentExecution ? parentExecution.flush : isAsync => {\n        return this.proxyStateTree.flush(mutationTrees, isAsync);\n      },\n      getMutationTree: parentExecution ? parentExecution.getMutationTree : () => {\n        const mutationTree = this.proxyStateTree.getMutationTree();\n        mutationTrees.push(mutationTree);\n\n        if (this.mode.mode === MODE_TEST) {\n          mutationTree.onMutation(mutation => {\n            this.addExecutionMutation(mutation);\n          });\n        }\n\n        return mutationTree;\n      },\n      getTrackStateTree: () => {\n        return this.proxyStateTree.getTrackStateTree();\n      },\n      onFlush: cb => {\n        return this.proxyStateTree.onFlush(cb);\n      },\n      scopeValue: (value, tree) => {\n        return this.scopeValue(value, tree);\n      }\n    };\n    return execution;\n  }\n\n  createContext(execution, tree) {\n    return {\n      state: tree.state,\n      actions: createActionsProxy(this.actions, action => {\n        return value => action(value, execution.isRunning ? execution : null);\n      }),\n      execution,\n      proxyStateTree: this.proxyStateTree,\n      effects: this.trackEffects(this.effects, execution),\n      revertable: cb => {\n        const mutations = [];\n        const dispose = this.addMutationListener(mutation => {\n          mutations.unshift(mutation);\n        });\n        cb();\n        dispose();\n        return () => mutations.forEach(mutation => mutation.revert());\n      }\n    };\n  }\n\n  scopeValue(value, tree) {\n    if (!value) {\n      return value;\n    }\n\n    if (value[IS_PROXY]) {\n      return this.proxyStateTree.rescope(value, tree);\n    } else if (isPlainObject(value)) {\n      return Object.assign({}, ...Object.keys(value).map(key => ({\n        [key]: this.proxyStateTree.rescope(value[key], tree)\n      })));\n    } else {\n      return value;\n    }\n  }\n\n  addExecutionMutation(mutation) {\n    ;\n    this.mutations.push(mutation);\n  }\n\n  createAction(name, action) {\n    this.actionReferences.push(action);\n\n    const actionFunc = (value, boundExecution) => {\n      // Developer might unintentionally pass more arguments, so have to ensure\n      // that it is an actual execution\n      boundExecution = boundExecution && boundExecution[EXECUTION] ? boundExecution : undefined;\n\n      if (process.env.NODE_ENV === 'production' || action[IS_OPERATOR]) {\n        const execution = this.createExecution(name, action, boundExecution);\n        this.eventHub.emit(EventType.ACTION_START, Object.assign(Object.assign({}, execution), {\n          value\n        }));\n\n        if (action[IS_OPERATOR]) {\n          return new Promise((resolve, reject) => {\n            action(null, Object.assign(Object.assign({}, this.createContext(execution, this.proxyStateTree)), {\n              value\n            }), (err, finalContext) => {\n              execution.isRunning = false;\n              finalContext && this.eventHub.emit(EventType.ACTION_END, Object.assign(Object.assign({}, finalContext.execution), {\n                operatorId: finalContext.execution.operatorId - 1\n              }));\n              if (err) reject(err);else {\n                resolve(this.mode.mode === MODE_TEST ? finalContext.execution : undefined);\n              }\n            });\n          });\n        } else {\n          const returnValue = action(this.createContext(execution, execution.getMutationTree()), value);\n          this.eventHub.emit(EventType.ACTION_END, execution);\n          return returnValue;\n        }\n      } else {\n        const execution = Object.assign(Object.assign({}, this.createExecution(name, action, boundExecution)), {\n          operatorId: 0,\n          type: 'action'\n        });\n        this.eventHub.emit(EventType.ACTION_START, Object.assign(Object.assign({}, execution), {\n          value\n        }));\n        this.eventHub.emit(EventType.OPERATOR_START, execution);\n        const mutationTree = execution.getMutationTree();\n        mutationTree.onMutation(mutation => {\n          this.eventHub.emit(EventType.MUTATIONS, Object.assign(Object.assign({}, execution), {\n            mutations: [mutation]\n          }));\n        });\n        const scopedValue = this.scopeValue(value, mutationTree);\n        const context = this.createContext(execution, mutationTree);\n\n        try {\n          const result = action(context, scopedValue);\n\n          if (isPromise(result)) {\n            this.eventHub.emit(EventType.OPERATOR_ASYNC, execution);\n            result.then(() => {\n              execution.isRunning = false;\n\n              if (!boundExecution) {\n                mutationTree.dispose();\n              }\n\n              this.eventHub.emit(EventType.OPERATOR_END, Object.assign(Object.assign({}, execution), {\n                isAsync: true,\n                result: undefined\n              }));\n              this.eventHub.emit(EventType.ACTION_END, execution);\n            }).catch(error => {\n              execution.isRunning = false;\n\n              if (!boundExecution) {\n                mutationTree.dispose();\n              }\n\n              this.eventHub.emit(EventType.OPERATOR_END, Object.assign(Object.assign({}, execution), {\n                isAsync: true,\n                result: undefined,\n                error: error.message\n              }));\n              this.eventHub.emit(EventType.ACTION_END, execution);\n              throw error;\n            });\n          } else {\n            execution.isRunning = false;\n\n            if (!boundExecution) {\n              mutationTree.dispose();\n            }\n\n            this.eventHub.emit(EventType.OPERATOR_END, Object.assign(Object.assign({}, execution), {\n              isAsync: false,\n              result: undefined\n            }));\n            this.eventHub.emit(EventType.ACTION_END, execution);\n          }\n\n          let pendingFlush;\n          mutationTree.onMutation(mutation => {\n            if (pendingFlush) {\n              clearTimeout(pendingFlush);\n            }\n\n            if (this.mode.mode === MODE_TEST) {\n              this.addExecutionMutation(mutation);\n            }\n\n            pendingFlush = setTimeout(() => {\n              pendingFlush = null;\n              const flushData = execution.flush(true);\n\n              if (this.devtools && flushData.mutations.length) {\n                this.devtools.send({\n                  type: 'flush',\n                  data: Object.assign(Object.assign(Object.assign({}, execution), flushData), {\n                    mutations: flushData.mutations\n                  })\n                });\n              }\n            });\n          });\n          return result;\n        } catch (err) {\n          this.eventHub.emit(EventType.OPERATOR_END, Object.assign(Object.assign({}, execution), {\n            isAsync: false,\n            result: undefined,\n            error: err.message\n          }));\n          this.eventHub.emit(EventType.ACTION_END, execution);\n          throw err;\n        }\n      }\n    };\n\n    return actionFunc;\n  }\n\n  trackEffects(effects = {}, execution) {\n    if (process.env.NODE_ENV === 'production') {\n      return effects;\n    }\n\n    return proxifyEffects(this.effects, effect => {\n      let result;\n\n      try {\n        if (this.mode.mode === MODE_TEST) {\n          const mode = this.mode;\n          result = mode.options.effectsCallback(effect);\n        } else {\n          this.eventHub.emit(EventType.EFFECT, Object.assign(Object.assign(Object.assign({}, execution), effect), {\n            args: effect.args,\n            isPending: true,\n            error: false\n          }));\n          result = effect.func.apply(this, effect.args);\n        }\n      } catch (error) {\n        // eslint-disable-next-line standard/no-callback-literal\n        this.eventHub.emit(EventType.EFFECT, Object.assign(Object.assign(Object.assign({}, execution), effect), {\n          args: effect.args,\n          isPending: false,\n          error: error.message\n        }));\n        throw error;\n      }\n\n      if (isPromise(result)) {\n        // eslint-disable-next-line standard/no-callback-literal\n        this.eventHub.emit(EventType.EFFECT, Object.assign(Object.assign(Object.assign({}, execution), effect), {\n          args: effect.args,\n          isPending: true,\n          error: false\n        }));\n        return result.then(promisedResult => {\n          // eslint-disable-next-line standard/no-callback-literal\n          this.eventHub.emit(EventType.EFFECT, Object.assign(Object.assign(Object.assign({}, execution), effect), {\n            args: effect.args,\n            result: promisedResult,\n            isPending: false,\n            error: false\n          }));\n          return promisedResult;\n        }).catch(error => {\n          this.eventHub.emit(EventType.EFFECT, Object.assign(Object.assign(Object.assign({}, execution), effect), {\n            args: effect.args,\n            isPending: false,\n            error: error && error.message\n          }));\n          throw error;\n        });\n      } // eslint-disable-next-line standard/no-callback-literal\n\n\n      this.eventHub.emit(EventType.EFFECT, Object.assign(Object.assign(Object.assign({}, execution), effect), {\n        args: effect.args,\n        result: result,\n        isPending: false,\n        error: false\n      }));\n      return result;\n    });\n  }\n\n  initializeDevtools(host, name, eventHub, initialState, actions) {\n    if (process.env.NODE_ENV === 'production') return;\n    const devtools = new Devtools(name);\n    devtools.connect(host, message => {\n      if (message.appName !== name) {\n        return;\n      }\n\n      switch (message.type) {\n        case 'refresh':\n          location.reload(true);\n          break;\n\n        case 'executeAction':\n          const action = message.data.name.split('.').reduce((aggr, key) => aggr[key], this.actions);\n          message.data.payload ? action(JSON.parse(message.data.payload)) : action();\n          break;\n\n        case 'mutation':\n          const tree = this.proxyStateTree.getMutationTree();\n          const path = message.data.path.slice();\n          const value = JSON.parse(`{ \"value\": ${message.data.value} }`).value;\n          const key = path.pop();\n          const state = path.reduce((aggr, key) => aggr[key], tree.state);\n          state[key] = value;\n          tree.flush(true);\n          tree.dispose();\n          this.devtools.send({\n            type: 'state',\n            data: {\n              path: message.data.path,\n              value\n            }\n          });\n      }\n    });\n\n    for (let type in EventType) {\n      eventHub.on(EventType[type], (eventType => data => {\n        devtools.send({\n          type: EventType[type],\n          data\n        });\n\n        if (eventType === EventType.MUTATIONS) {\n          // We want to trigger property access when setting objects and arrays, as any derived set would\n          // then trigger and update the devtools\n          data.mutations.forEach(mutation => {\n            const value = mutation.path.split(this.delimiter).reduce((aggr, key) => aggr[key], this.proxyStateTree.state);\n\n            if (isPlainObject(value)) {\n              Object.keys(value).forEach(key => value[key]);\n            } else if (Array.isArray(value)) {\n              value.forEach(item => {\n                if (isPlainObject(item)) {\n                  Object.keys(item).forEach(key => item[key]);\n                }\n              });\n            }\n          });\n        } // Access the derived which will trigger calculation and devtools\n\n\n        if (eventType === EventType.DERIVED_DIRTY) {\n          data.derivedPath.reduce((aggr, key) => aggr[key], this.proxyStateTree.state);\n        }\n      })(EventType[type]));\n    }\n\n    devtools.send({\n      type: 'init',\n      data: {\n        state: this.proxyStateTree.state,\n        actions: getActionPaths(actions),\n        delimiter: this.delimiter\n      }\n    });\n    this.devtools = devtools;\n  }\n\n  getState(configuration) {\n    let state = {};\n\n    if (configuration.state) {\n      state = processState(configuration.state);\n    }\n\n    return state;\n  }\n\n  getActions(actions = {}, path = []) {\n    return Object.keys(actions).reduce((aggr, name) => {\n      if (typeof actions[name] === 'function') {\n        const action = this.createAction(path.concat(name).join('.'), actions[name]);\n        action.displayName = path.concat(name).join('.');\n        return Object.assign(aggr, {\n          [name]: action\n        });\n      }\n\n      return Object.assign(aggr, {\n        [name]: this.getActions(actions[name], path.concat(name))\n      });\n    }, {});\n  }\n\n  getTrackStateTree() {\n    return this.proxyStateTree.getTrackStateTree();\n  }\n\n  getMutationTree() {\n    return this.proxyStateTree.getMutationTree();\n  }\n\n  reconfigure(configuration) {\n    const mergedConfiguration = Object.assign(Object.assign({}, configuration), {\n      state: mergeState(this.originalConfiguration.state, this.state, configuration.state)\n    });\n    const proxyStateTree = this.proxyStateTree;\n    this.originalConfiguration.state = configuration.state;\n    this.proxyStateTree.sourceState = this.getState(mergedConfiguration);\n    proxyStateTree.createTrackStateProxifier();\n    this.state = this.proxyStateTree.state;\n    this.actions = this.getActions(mergedConfiguration.actions);\n    this.effects = mergedConfiguration.effects || {};\n    this.proxyStateTree.forceFlush();\n\n    if (this.devtools) {\n      this.devtools.send({\n        type: 're_init',\n        data: {\n          state: proxyStateTree.state,\n          actions: getActionPaths(configuration.actions)\n        }\n      });\n    }\n\n    return this;\n  }\n\n}\nexport function pipe(...operators) {\n  const instance = (err, context, next, final = next) => {\n    if (err) next(err, context);else {\n      let operatorIndex = 0;\n\n      const run = (operatorErr, operatorContext) => {\n        const operator = operators[operatorIndex++];\n\n        try {\n          ;\n          (operator || next)(operatorErr, operatorContext, run, final);\n        } catch (operatorError) {\n          ;\n          (operator || next)(operatorError, operatorContext, run, final);\n        }\n      };\n\n      run(null, context);\n    }\n  };\n\n  instance[IS_OPERATOR] = true;\n  return instance;\n}\n/*\n  OPERATORS\n*/\n\nexport function forEach(forEachItemOperator) {\n  const instance = (err, context, next) => {\n    if (err) next(err, context);else {\n      let array = context.value;\n      let evaluatingCount = array.length;\n      let lastContext;\n      let hasErrored = false;\n\n      const evaluate = err => {\n        if (hasErrored) {\n          return;\n        }\n\n        if (err) {\n          hasErrored = true;\n          return next(err);\n        }\n\n        evaluatingCount--;\n\n        if (!evaluatingCount) {\n          operatorStopped(context, context.value);\n          next(null, createContext(lastContext, context.value, lastContext.execution.path && lastContext.execution.path.slice(0, lastContext.execution.path.length - 1)));\n        }\n      };\n\n      operatorStarted('forEach', '', context);\n\n      if (array.length) {\n        array.forEach((value, index) => {\n          lastContext = createContext(lastContext || context, value, context.execution.path && context.execution.path.concat(String(index)));\n          const nextWithPath = createNextPath(evaluate); // @ts-ignore\n\n          forEachItemOperator(null, lastContext, nextWithPath);\n        });\n      } else {\n        operatorStopped(context, context.value);\n        next(null, createContext(context, context.value));\n      }\n    }\n  };\n\n  instance[IS_OPERATOR] = true;\n  return instance;\n}\nexport function parallel(...operators) {\n  const instance = (err, context, next) => {\n    if (err) next(err, context);else {\n      let evaluatingCount = operators.length;\n      let lastContext;\n      let hasErrored = false;\n\n      const evaluate = err => {\n        if (hasErrored) {\n          return;\n        }\n\n        if (err) {\n          hasErrored = true;\n          return next(err, lastContext);\n        }\n\n        evaluatingCount--;\n\n        if (!evaluatingCount) {\n          operatorStopped(context, context.value);\n          next(null, createContext(lastContext, context.value, lastContext.execution.path && lastContext.execution.path.slice(0, lastContext.execution.path.length - 1)));\n        }\n      };\n\n      operatorStarted('parallel', '', context);\n      operators.forEach((operator, index) => {\n        lastContext = createContext(lastContext || context, context.value, context.execution.path && context.execution.path.concat(String(index)));\n        const nextWithPath = createNextPath(evaluate); // @ts-ignore\n\n        operator(null, lastContext, nextWithPath);\n      });\n    }\n  };\n\n  instance[IS_OPERATOR] = true;\n  return instance;\n}\nexport function map(operation) {\n  return createOperator('map', getFunctionName(operation), (err, context, value, next) => {\n    if (err) next(err, value);else next(null, operation(context, value));\n  });\n}\nexport function noop() {\n  return createOperator('noop', '', (err, context, value, next) => {\n    if (err) next(err, value);else next(null, value);\n  });\n}\nexport function filter(operation) {\n  return createOperator('filter', getFunctionName(operation), (err, context, value, next, final) => {\n    if (err) next(err, value);else if (operation(context, value)) next(null, value);else final(null, value);\n  });\n}\nlet hasShownActionDeprecation = false;\nexport function action(operation) {\n  if (!hasShownActionDeprecation) {\n    console.warn(`DEPRECATION - The action operator is deprecated in favor of \"mutate\". The reason is to avoid confusion between actions and operators. Check out action \"${getFunctionName(operation)}\"`);\n    hasShownActionDeprecation = true;\n  }\n\n  return createMutationOperator('action', getFunctionName(operation), (err, context, value, next) => {\n    if (err) next(err, value);else {\n      const result = operation(context, value);\n\n      if (isPromise(result)) {\n        next(null, result.then(() => value));\n      } else {\n        next(null, value);\n      }\n    }\n  });\n}\nexport function mutate(operation) {\n  return createMutationOperator('mutate', getFunctionName(operation), (err, context, value, next) => {\n    if (err) next(err, value);else {\n      const result = operation(context, value);\n\n      if (isPromise(result)) {\n        next(null, result.then(() => value));\n      } else {\n        next(null, value);\n      }\n    }\n  });\n}\nexport function run(operation) {\n  return createOperator('run', getFunctionName(operation), (err, context, value, next) => {\n    if (err) next(err, value);else {\n      const result = operation(context, value);\n\n      if (isPromise(result)) {\n        next(null, result.then(() => value));\n      } else {\n        next(null, value);\n      }\n    }\n  });\n}\nexport function catchError(operation) {\n  return createMutationOperator('catchError', getFunctionName(operation), (err, context, value, next) => {\n    if (err) next(null, operation(context, err));else next(null, value, {\n      isSkipped: true\n    });\n  });\n}\nexport function tryCatch(paths) {\n  const instance = (err, context, next) => {\n    if (err) next(err, context);else {\n      const evaluateCatch = (err, catchContext) => {\n        operatorStopped(context, context.value);\n        next(err, createContext(catchContext, context.value));\n      };\n\n      const evaluateTry = (err, tryContext) => {\n        if (err) {\n          const newContext = createContext(tryContext, err, context.execution.path && context.execution.path.concat('catch'));\n          const nextWithPath = createNextPath(evaluateCatch); // @ts-ignore\n\n          paths.catch(null, newContext, nextWithPath);\n        } else {\n          operatorStopped(context, context.value);\n          next(null, createContext(tryContext, context.value));\n        }\n      };\n\n      operatorStarted('tryCatch', '', context);\n      const newContext = createContext(context, context.value, context.execution.path && context.execution.path.concat('try'));\n      const nextWithPath = createNextPath(evaluateTry); // @ts-ignore\n\n      paths.try(null, newContext, nextWithPath);\n    }\n  };\n\n  instance[IS_OPERATOR] = true;\n  return instance;\n}\nexport function fork(operation, paths) {\n  return createOperator('fork', getFunctionName(operation), (err, context, value, next) => {\n    if (err) next(err, value);else {\n      const path = operation(context, value);\n      next(null, value, {\n        path: {\n          name: String(path),\n          operator: paths[path]\n        }\n      });\n    }\n  });\n}\nexport function when(operation, paths) {\n  return createOperator('when', getFunctionName(operation), (err, context, value, next) => {\n    if (err) next(err, value);else if (operation(context, value)) next(null, value, {\n      path: {\n        name: 'true',\n        operator: paths.true\n      }\n    });else next(null, value, {\n      path: {\n        name: 'false',\n        operator: paths.false\n      }\n    });\n  });\n}\nexport function wait(ms) {\n  return createOperator('wait', String(ms), (err, context, value, next) => {\n    if (err) next(err, value);else setTimeout(() => next(null, value), ms);\n  });\n}\nexport function debounce(ms) {\n  let timeout;\n  let previousFinal;\n  return createOperator('debounce', String(ms), (err, context, value, next, final) => {\n    if (err) next(err, value);else {\n      if (timeout) {\n        clearTimeout(timeout);\n        previousFinal(null, value);\n      }\n\n      previousFinal = final;\n      timeout = setTimeout(() => {\n        timeout = null;\n        next(null, value);\n      }, ms);\n    }\n  });\n}\nexport function throttle(ms) {\n  let timeout;\n  let previousFinal;\n  let currentNext;\n  return createOperator('throttle', String(ms), (err, context, value, next, final) => {\n    if (err) next(err, value);else {\n      if (timeout) {\n        previousFinal(null, value);\n        currentNext = next;\n      } else {\n        timeout = setTimeout(() => {\n          timeout = null;\n          currentNext(null, value);\n        }, ms);\n      }\n\n      previousFinal = final;\n      currentNext = next;\n    }\n  });\n}\nexport function waitUntil(operation) {\n  return createOperator('waitUntil', operation.name, (err, context, value, next) => {\n    if (err) next(err, value);else {\n      const tree = context.execution.getTrackStateTree();\n\n      const test = () => {\n        if (operation(tree.state)) {\n          tree.dispose();\n          next(null, value);\n        }\n      };\n\n      tree.trackScope(test, test);\n    }\n  });\n}","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'betsy'\nimport isPlainObject from 'is-plain-obj'\nimport {\n  IFlushCallback,\n  IMutation,\n  IMutationCallback,\n  IMutationTree,\n  IS_PROXY,\n  ITrackStateTree,\n  PATH,\n  ProxyStateTree,\n  TTree,\n  VALUE,\n} from 'proxy-state-tree'\n\nimport { Derived, IS_DERIVED } from './derived'\nimport { Devtools, DevtoolsMessage } from './Devtools'\nimport {\n  DefaultMode,\n  EventType,\n  Events,\n  Execution,\n  NestedPartial,\n  Options,\n  ResolveActions,\n  ResolveState,\n  SSRMode,\n  TestMode\n} from './internalTypes'\nimport {\n  createContext,\n  createMutationOperator,\n  createNextPath,\n  createOperator,\n  operatorStarted,\n  operatorStopped,\n} from './operator'\nimport { proxifyEffects } from './proxyfyEffects'\nimport {\n  IAction,\n  IConfiguration,\n  IContext,\n  IDerive,\n  IOnInitialize,\n  IOperator,\n  IReaction,\n  IState,\n} from './types'\nimport {\n  EXECUTION,\n  IS_OPERATOR,\n  IS_TEST,\n  MODE_DEFAULT,\n  MODE_SSR,\n  MODE_TEST,\n  MockedEventEmitter,\n  createActionsProxy,\n  deepCopy,\n  getActionPaths,\n  getFunctionName,\n  isPromise,\n  mergeState,\n  processState,\n} from './utils'\n\nexport * from './types'\n\nexport { createOperator, createMutationOperator, ResolveState, ResolveActions }\n\nexport { MODE_DEFAULT, MODE_TEST, MODE_SSR } from './utils'\n\nexport { SERIALIZE, rehydrate } from './rehydrate'\n\nexport { Statemachine, statemachine } from './statemachine'\n\nexport const derived = <S extends IState, V, C = Config>(cb: IDerive<C, S, V>): V => cb as any\n\n/** This type can be overwriten by app developers if they want to avoid\n * typing and then they can import `Action`,  `Operation` etc. directly from\n * overmind.\n */\nexport interface Config {}\n\nexport interface Context extends IContext<Config> {}\n\nexport interface Action<Value = void, ReturnValue = void>\n  extends IAction<Config, Value, ReturnValue> {}\n\nexport interface AsyncAction<Value = void, ReturnValue = void>\n  extends IAction<Config, Value, Promise<ReturnValue>> {}\n\nexport interface Derive<Parent extends IState, Value>\n  extends IDerive<Config, Parent, Value> {}\n\nexport interface OnInitialize extends IOnInitialize<Config> {}\n\nexport interface Reaction extends IReaction<Config> {}\n\nexport { json } from './utils'\n\nexport interface OvermindSSR<Config extends IConfiguration>\n  extends Overmind<Config> {\n  hydrate(): IMutation[]\n}\n\nexport function createOvermindSSR<Config extends IConfiguration>(\n  config: Config\n): OvermindSSR<Config> {\n  const ssr = new Overmind(\n    config,\n    {\n      devtools: false,\n    },\n    {\n      mode: MODE_SSR,\n    } as SSRMode\n  ) as any\n\n  const mutationTree = ssr.proxyStateTree.getMutationTree()\n\n  ssr.state = mutationTree.state\n  ssr.hydrate = () => {\n    return mutationTree.flush().mutations\n  }\n  return ssr\n}\n\nexport interface OvermindMock<Config extends IConfiguration>\n  extends Overmind<Config> {\n  onInitialize: () => Promise<IMutation[]>\n  mutations: IMutation[]\n}\n\nexport function createOvermindMock<Config extends IConfiguration>(\n  config: Config,\n  mockedEffects?: NestedPartial<Config['effects']>\n): OvermindMock<Config> {\n  const mock = new Overmind(\n    Object.assign({}, config, {\n      state: deepCopy(config.state),\n    }),\n    {\n      devtools: false,\n    },\n    {\n      mode: MODE_TEST,\n      options: {\n        effectsCallback: (effect) => {\n          const mockedEffect = (effect.name\n            ? effect.name.split('.')\n            : []\n          ).reduce((aggr, key) => (aggr ? aggr[key] : aggr), mockedEffects)\n\n          if (!mockedEffect || (mockedEffect && !mockedEffect[effect.method])) {\n            throw new Error(\n              `The effect \"${effect.name}\" with method ${\n                effect.method\n              } has not been mocked`\n            )\n          }\n          return mockedEffect[effect.method](...effect.args)\n        },\n      },\n    } as TestMode\n  ) as OvermindMock<Config>\n\n  const action = (mock as any).createAction('onInitialize', config.onInitialize)\n\n  mock.onInitialize = () => action(mock)\n  mock.mutations = []\n\n  return mock as any\n}\n\nexport function createOvermind<Config extends IConfiguration>(\n  config: Config,\n  options?: Options\n): Overmind<Config> {\n  return new Overmind(config, options, { mode: MODE_DEFAULT })\n}\n\nconst hotReloadingCache = {}\n\n// We do not use IConfig<Config> directly to type the class in order to avoid\n// the 'import(...)' function to be used in exported types.\nexport class Overmind<ThisConfig extends IConfiguration>\n  implements IConfiguration {\n  private proxyStateTree: ProxyStateTree<object>\n  private actionReferences: Function[] = []\n  private nextExecutionId: number = 0\n  private mode: DefaultMode | TestMode | SSRMode\n  private originalConfiguration\n  initialized: Promise<any>\n  eventHub: EventEmitter<Events>\n  devtools: Devtools\n  actions: ResolveActions<ThisConfig['actions']>\n  state: ResolveState<ThisConfig['state']>\n  effects: ThisConfig['effects'] & {}\n  delimiter: string\n  constructor(\n    configuration: ThisConfig,\n    options: Options = {},\n    mode: DefaultMode | TestMode | SSRMode = {\n      mode: MODE_DEFAULT,\n    } as DefaultMode\n  ) {\n    const name = options.name || 'OvermindApp'\n\n    this.delimiter = options.delimiter || '.'\n\n    if (\n      (!process.env.NODE_ENV || process.env.NODE_ENV === 'development') &&\n      mode.mode === MODE_DEFAULT &&\n      options.hotReloading !== false &&\n      !(process && process.title && process.title.includes('node'))\n    ) {\n      if (hotReloadingCache[name]) {\n        return hotReloadingCache[name].reconfigure(configuration)\n      } else {\n        hotReloadingCache[name] = this\n      }\n    }\n\n    /*\n      Set up an eventHub to trigger information from derived, computed and reactions\n    */\n    const eventHub =\n      mode.mode === MODE_SSR\n        ? new MockedEventEmitter()\n        : new EventEmitter<Events>()\n\n    /*\n      Create the proxy state tree instance with the state and a wrapper to expose\n      the eventHub\n    */\n    const proxyStateTree = this.createProxyStateTree(\n      configuration,\n      eventHub,\n      mode.mode === MODE_SSR ? false : process.env.NODE_ENV === 'development'\n    )\n\n    this.originalConfiguration = configuration\n    this.state = proxyStateTree.state\n    this.effects = configuration.effects || {}\n    this.proxyStateTree = proxyStateTree\n    this.eventHub = eventHub as EventEmitter<Events>\n    this.mode = mode\n\n\n    /*\n      Expose the created actions\n    */\n    this.actions = this.getActions(configuration.actions)\n    \n    if (mode.mode === MODE_SSR) {\n      return\n    }\n\n    if (\n      process.env.NODE_ENV === 'development' &&\n      mode.mode === MODE_DEFAULT &&\n      typeof window !== 'undefined'\n    ) {\n      let warning = 'OVERMIND: You are running in DEVELOPMENT mode.'\n      if (options.logProxies !== true) {\n        const originalConsoleLog = console.log\n\n        console.log = (...args) =>\n          originalConsoleLog.apply(\n            console,\n            args.map((arg) => (arg && arg[IS_PROXY] ? arg[VALUE] : arg))\n          )\n        warning +=\n          '\\n\\n - To improve debugging experience \"console.log\" will NOT log proxies from Overmind, but the actual value. Please see docs to turn off this behaviour'\n      }\n\n      if (\n        options.devtools ||\n        (typeof location !== 'undefined' &&\n          location.hostname === 'localhost' &&\n          options.devtools !== false)\n      ) {\n        const host =\n          options.devtools === true ? 'localhost:3031' : options.devtools\n        const name = options.name\n          ? options.name\n          : typeof document === 'undefined'\n          ? 'NoName'\n          : document.title || 'NoName'\n\n        this.initializeDevtools(\n          host,\n          name,\n          eventHub,\n          proxyStateTree.sourceState,\n          configuration.actions\n        )\n      } else {\n        warning +=\n          '\\n\\n - You are not running on localhost. You will have to manually define the devtools option to connect'\n      }\n\n      if (!IS_TEST) {\n        console.warn(warning)\n      }\n    }\n\n    if (process.env.NODE_ENV === 'production' && mode.mode === MODE_DEFAULT) {\n      eventHub.on(EventType.OPERATOR_ASYNC, () => {\n        proxyStateTree.getMutationTree().flush(true)\n      })\n      eventHub.on(EventType.ACTION_END, (execution) => {\n        if (!execution.parentExecution || !execution.parentExecution.isRunning)\n          proxyStateTree.getMutationTree().flush()\n      })\n\n      let nextTick\n      const flushTree = () => {\n        proxyStateTree.getMutationTree().flush(true)\n      }\n\n      this.proxyStateTree.onMutation(() => {\n        nextTick && clearTimeout(nextTick)\n        nextTick = setTimeout(flushTree, 0)\n      })\n    } else if (mode.mode === MODE_DEFAULT || mode.mode === MODE_TEST) {\n      eventHub.on(EventType.OPERATOR_ASYNC, (execution) => {\n        const flushData = execution.flush(true)\n        if (this.devtools && flushData.mutations.length) {\n          this.devtools.send({\n            type: 'flush',\n            data: {\n              ...execution,\n              ...flushData,\n            },\n          })\n        }\n      })\n      eventHub.on(EventType.ACTION_END, (execution) => {\n        if (\n          !execution.parentExecution ||\n          !execution.parentExecution.isRunning\n        ) {\n          const flushData = execution.flush()\n\n          if (this.devtools && flushData.mutations.length) {\n            this.devtools.send({\n              type: 'flush',\n              data: {\n                ...execution,\n                ...flushData,\n              },\n            })\n          }\n        }\n      })\n    }\n\n    if (mode.mode === MODE_DEFAULT && configuration.onInitialize) {\n      const onInitialize = this.createAction(\n        'onInitialize',\n        configuration.onInitialize\n      ) as any\n\n      this.initialized = Promise.resolve(onInitialize(this))\n    } else {\n      this.initialized = Promise.resolve(null)\n    }\n  }\n  private createProxyStateTree(\n    configuration: IConfiguration,\n    eventHub: EventEmitter<any> | MockedEventEmitter,\n    devmode: boolean\n  ) {\n    const proxyStateTree = new ProxyStateTree(\n      this.getState(configuration) as any,\n      {\n        devmode,\n        delimiter: this.delimiter,\n        onFunction: (tree, path, func) => {\n          if (func[IS_DERIVED]) {\n            return { func, value: func(eventHub, tree, proxyStateTree, path.split(this.delimiter)) }\n          }\n\n          const derived = new Derived(func) as any\n\n          return {\n            func: derived,\n            value: derived(eventHub, tree, proxyStateTree, path.split(this.delimiter))\n          }\n        },    \n        onGetter: devmode\n          ? (path, value) => {\n              this.eventHub.emitAsync(EventType.GETTER, {\n                path,\n                value\n              })\n            }\n          : undefined,\n      }\n    )\n\n    return proxyStateTree\n  }\n  private createExecution(name, action, parentExecution) {\n    const namespacePath = name.split('.')\n\n    namespacePath.pop()\n\n    if (process.env.NODE_ENV === 'production') {\n      return ({\n        [EXECUTION]: true,\n        parentExecution,\n        namespacePath,\n        actionName: name,\n        getMutationTree: () => {\n          return this.proxyStateTree.getMutationTree()\n        },\n        getTrackStateTree: () => {\n          return this.proxyStateTree.getTrackStateTree()\n        },\n        emit: this.eventHub.emit.bind(this.eventHub),\n      } as any) as Execution\n    }\n\n    const mutationTrees: any[] = []\n    const execution = {\n      [EXECUTION]: true,\n      namespacePath,\n      actionId: this.actionReferences.indexOf(action),\n      executionId: this.nextExecutionId++,\n      actionName: name,\n      operatorId: 0,\n      isRunning: true,\n      parentExecution,\n      path: [],\n      emit: this.eventHub.emit.bind(this.eventHub),\n      send: this.devtools ? this.devtools.send.bind(this.devtools) : () => {},\n      trackEffects: this.trackEffects.bind(this, this.effects),\n      getNextOperatorId: (() => {\n        let currentOperatorId = 0\n        return () => ++currentOperatorId\n      })(),\n      flush: parentExecution\n        ? parentExecution.flush\n        : (isAsync?: boolean) => {\n            return this.proxyStateTree.flush(mutationTrees, isAsync)\n          },\n      getMutationTree: parentExecution\n        ? parentExecution.getMutationTree\n        : () => {\n            const mutationTree = this.proxyStateTree.getMutationTree()\n\n            mutationTrees.push(mutationTree)\n\n            if (this.mode.mode === MODE_TEST) {\n              mutationTree.onMutation((mutation) => {\n                this.addExecutionMutation(mutation)\n              })\n            }\n            return mutationTree\n          },\n      getTrackStateTree: () => {\n        return this.proxyStateTree.getTrackStateTree()\n      },\n      onFlush: (cb) => {\n        return this.proxyStateTree.onFlush(cb)\n      },\n      scopeValue: (value, tree) => {\n        return this.scopeValue(value, tree)\n      },\n    }\n\n    return execution\n  }\n  private createContext(execution, tree) {\n    return {\n      state: tree.state,\n      actions: createActionsProxy(this.actions, (action) => {\n        return (value) => action(value, execution.isRunning ? execution : null)\n      }),\n      execution,\n      proxyStateTree: this.proxyStateTree,\n      effects: this.trackEffects(this.effects, execution),\n      revertable: (cb: () => void) => {\n        const mutations: IMutation[] = []\n        const dispose = this.addMutationListener((mutation) => {\n          mutations.unshift(mutation)\n        })\n        cb()\n        dispose()\n        return () => mutations.forEach((mutation) => mutation.revert())\n      },\n    }\n  }\n  private scopeValue(value: any, tree: TTree) {\n    if (!value) {\n      return value\n    }\n    if (value[IS_PROXY]) {\n      return this.proxyStateTree.rescope(value, tree)\n    } else if (isPlainObject(value)) {\n      return Object.assign(\n        {},\n        ...Object.keys(value).map((key) => ({\n          [key]: this.proxyStateTree.rescope(value[key], tree),\n        }))\n      )\n    } else {\n      return value\n    }\n  }\n  private addExecutionMutation(mutation: IMutation) {\n    ;((this as unknown) as OvermindMock<Config>).mutations.push(mutation)\n  }\n  private createAction(name, action) {\n    this.actionReferences.push(action)\n    const actionFunc = (value?, boundExecution?: Execution) => {\n      // Developer might unintentionally pass more arguments, so have to ensure\n      // that it is an actual execution\n      boundExecution =\n        boundExecution && boundExecution[EXECUTION] ? boundExecution : undefined\n\n      if (process.env.NODE_ENV === 'production' || action[IS_OPERATOR]) {\n        const execution = this.createExecution(name, action, boundExecution)\n        this.eventHub.emit(EventType.ACTION_START, {\n          ...execution,\n          value\n        })\n\n        if (action[IS_OPERATOR]) {\n          return new Promise((resolve, reject) => {\n            action(\n              null,\n              {\n                ...this.createContext(execution, this.proxyStateTree),\n                value,\n              },\n              (err, finalContext) => {\n                execution.isRunning = false\n                finalContext &&\n                  this.eventHub.emit(EventType.ACTION_END, {\n                    ...finalContext.execution,\n                    operatorId: finalContext.execution.operatorId - 1,\n                  })\n                if (err) reject(err)\n                else {\n                  resolve(\n                    this.mode.mode === MODE_TEST\n                      ? finalContext.execution\n                      : undefined\n                  )\n                }\n              }\n            )\n          })\n        } else {\n          const returnValue = action(\n            this.createContext(execution, execution.getMutationTree()),\n            value\n          )\n\n          this.eventHub.emit(EventType.ACTION_END, execution)\n\n          return returnValue\n        }\n      } else {\n        const execution = {\n          ...this.createExecution(name, action, boundExecution),\n          operatorId: 0,\n          type: 'action',\n        }\n        this.eventHub.emit(EventType.ACTION_START, {\n          ...execution,\n          value\n        })\n        this.eventHub.emit(EventType.OPERATOR_START, execution)\n\n        const mutationTree = execution.getMutationTree()\n\n        mutationTree.onMutation((mutation) => {\n          this.eventHub.emit(EventType.MUTATIONS, {\n            ...execution,\n            mutations: [mutation],\n          })\n        })\n\n        const scopedValue = this.scopeValue(value, mutationTree)\n        const context = this.createContext(execution, mutationTree)\n\n        try {\n          const result = action(context, scopedValue)\n\n          if (isPromise(result)) {\n            this.eventHub.emit(EventType.OPERATOR_ASYNC, execution)\n            result\n              .then(() => {\n                execution.isRunning = false\n                if (!boundExecution) {\n                  mutationTree.dispose()\n                }\n                this.eventHub.emit(EventType.OPERATOR_END, {\n                  ...execution,\n                  isAsync: true,\n                  result: undefined,\n                })\n                this.eventHub.emit(EventType.ACTION_END, execution)\n              })\n              .catch((error) => {\n                execution.isRunning = false\n                if (!boundExecution) {\n                  mutationTree.dispose()\n                }\n                this.eventHub.emit(EventType.OPERATOR_END, {\n                  ...execution,\n                  isAsync: true,\n                  result: undefined,\n                  error: error.message,\n                })\n                this.eventHub.emit(EventType.ACTION_END, execution)\n\n                throw error\n              })\n          } else {\n            execution.isRunning = false\n            if (!boundExecution) {\n              mutationTree.dispose()\n            }\n            this.eventHub.emit(EventType.OPERATOR_END, {\n              ...execution,\n              isAsync: false,\n              result: undefined,\n            })\n            this.eventHub.emit(EventType.ACTION_END, execution)\n          }\n\n          let pendingFlush\n          mutationTree.onMutation((mutation) => {\n            if (pendingFlush) {\n              clearTimeout(pendingFlush)\n            }\n\n            if (this.mode.mode === MODE_TEST) {\n              this.addExecutionMutation(mutation)\n            }\n\n            pendingFlush = setTimeout(() => {\n              pendingFlush = null\n              const flushData = execution.flush(true)\n\n              if (this.devtools && flushData.mutations.length) {\n                this.devtools.send({\n                  type: 'flush',\n                  data: {\n                    ...execution,\n                    ...flushData,\n                    mutations: flushData.mutations,\n                  },\n                })\n              }\n            })\n          })\n\n          return result\n        } catch (err) {\n          this.eventHub.emit(EventType.OPERATOR_END, {\n            ...execution,\n            isAsync: false,\n            result: undefined,\n            error: err.message,\n          })\n          this.eventHub.emit(EventType.ACTION_END, execution)\n          throw err\n        }\n      }\n    }\n\n    return actionFunc\n  }\n  private trackEffects(effects = {}, execution) {\n    \n    if (process.env.NODE_ENV === 'production') {\n      return effects\n    }\n\n    return proxifyEffects(this.effects, (effect) => {\n      let result\n      try {\n        if (this.mode.mode === MODE_TEST) {\n          const mode = this.mode as TestMode\n          result = mode.options.effectsCallback(effect)\n        } else {\n          this.eventHub.emit(EventType.EFFECT, {\n            ...execution,\n            ...effect,\n            args: effect.args,\n            isPending: true,\n            error: false,\n          })\n          result = effect.func.apply(this, effect.args)\n        }\n      } catch (error) {\n        // eslint-disable-next-line standard/no-callback-literal\n        this.eventHub.emit(EventType.EFFECT, {\n          ...execution,\n          ...effect,\n          args: effect.args,\n          isPending: false,\n          error: error.message,\n        })\n        throw error\n      }\n\n      if (isPromise(result)) {\n        // eslint-disable-next-line standard/no-callback-literal\n        this.eventHub.emit(EventType.EFFECT, {\n          ...execution,\n          ...effect,\n          args: effect.args,\n          isPending: true,\n          error: false,\n        })\n\n        return result\n          .then((promisedResult) => {\n            // eslint-disable-next-line standard/no-callback-literal\n            this.eventHub.emit(EventType.EFFECT, {\n              ...execution,\n              ...effect,\n              args: effect.args,\n              result: promisedResult,\n              isPending: false,\n              error: false,\n            })\n\n            return promisedResult\n          })\n          .catch((error) => {\n            this.eventHub.emit(EventType.EFFECT, {\n              ...execution,\n              ...effect,\n              args: effect.args,\n              isPending: false,\n              error: error && error.message,\n            })\n            throw error\n          })\n      }\n\n      // eslint-disable-next-line standard/no-callback-literal\n      this.eventHub.emit(EventType.EFFECT, {\n        ...execution,\n        ...effect,\n        args: effect.args,\n        result: result,\n        isPending: false,\n        error: false,\n      })\n\n      return result\n    })\n  }\n  private initializeDevtools(host, name, eventHub, initialState, actions) {\n    if (process.env.NODE_ENV === 'production') return\n    const devtools = new Devtools(name)\n    devtools.connect(\n      host,\n      (message: DevtoolsMessage) => {\n        if (message.appName !== name) {\n          return\n        }\n\n        switch (message.type) {\n          case 'refresh':\n            location.reload(true)\n            break\n          case 'executeAction':\n            const action = message.data.name\n              .split('.')\n              .reduce((aggr, key) => aggr[key], this.actions)\n            message.data.payload\n              ? action(JSON.parse(message.data.payload))\n              : action()\n            break\n          case 'mutation':\n            const tree = this.proxyStateTree.getMutationTree()\n            const path = message.data.path.slice()\n            const value = JSON.parse(`{ \"value\": ${message.data.value} }`).value\n            const key = path.pop()\n            const state = path.reduce((aggr, key) => aggr[key], tree.state)\n\n            state[key] = value\n            tree.flush(true)\n            tree.dispose()\n            this.devtools.send({\n              type: 'state',\n              data: {\n                path: message.data.path,\n                value,\n              },\n            })\n        }\n      }\n    )\n    for (let type in EventType) {\n      eventHub.on(\n        EventType[type],\n        ((eventType) => (data) => {\n          devtools.send({\n            type: EventType[type],\n            data,\n          })\n\n          if (eventType === EventType.MUTATIONS) {\n            // We want to trigger property access when setting objects and arrays, as any derived set would\n            // then trigger and update the devtools\n            data.mutations.forEach((mutation) => {\n              const value = mutation.path.split(this.delimiter).reduce((aggr, key) => aggr[key], this.proxyStateTree.state)\n              if (isPlainObject(value)) {\n                Object.keys(value).forEach((key) => value[key])\n              } else if (Array.isArray(value)) {\n                value.forEach((item) => {\n                  if (isPlainObject(item)) {\n                    Object.keys(item).forEach((key) => item[key])\n                  }\n                })\n              }\n            })\n          }\n          \n          // Access the derived which will trigger calculation and devtools\n          if (eventType === EventType.DERIVED_DIRTY) {\n            data.derivedPath\n              .reduce((aggr, key) => aggr[key], this.proxyStateTree.state)\n          }\n        })(EventType[type])\n      )\n    }\n    devtools.send({\n      type: 'init',\n      data: {\n        state: this.proxyStateTree.state,\n        actions: getActionPaths(actions),\n        delimiter: this.delimiter\n      },\n    })\n    this.devtools = devtools\n  }\n  private getState(configuration: IConfiguration) {\n    let state = {}\n    if (configuration.state) {\n      state = processState(\n        configuration.state,\n      )\n    }\n\n    return state\n  }\n  private getActions(actions: any = {}, path: string[] = []) {\n    return Object.keys(actions).reduce((aggr, name) => {\n      if (typeof actions[name] === 'function') {\n        const action = this.createAction(\n          path.concat(name).join('.'),\n          actions[name]\n        ) as any\n\n        action.displayName = path.concat(name).join('.')\n\n        return Object.assign(aggr, {\n          [name]: action,\n        })\n      }\n\n      return Object.assign(aggr, {\n        [name]: this.getActions(actions[name], path.concat(name)),\n      })\n    }, {}) as any\n  }\n  getTrackStateTree(): ITrackStateTree<any> {\n    return this.proxyStateTree.getTrackStateTree()\n  }\n  getMutationTree(): IMutationTree<any> {\n    return this.proxyStateTree.getMutationTree()\n  }\n  reaction: IReaction<ThisConfig> = (\n    stateCallback,\n    updateCallback,\n    options = {}\n  ) => {\n    let disposer\n\n    if (options.nested) {\n      const value = stateCallback(this.state)\n\n      if (!value || !value[IS_PROXY]) {\n        throw new Error(\n          'You have to return an object or array from the Overmind state when using a \"nested\" reaction'\n        )\n      }\n\n      const path = value[PATH]\n\n      disposer = this.addFlushListener((mutations) => {\n        mutations.forEach((mutation) => {\n          if (mutation.path.startsWith(path)) {\n            updateCallback(\n              path.split(this.delimiter).reduce((aggr, key) => aggr[key], this.state)\n            )\n          }\n        })\n      })\n    } else {\n      const tree = this.proxyStateTree.getTrackStateTree()\n      let returnValue\n      const updateReaction = () => {\n        tree.trackScope(\n          () => (returnValue = stateCallback(tree.state as any)),\n          () => {\n            updateReaction()\n            updateCallback(returnValue)\n          }\n        )\n      }\n\n      updateReaction()\n\n      disposer = () => {\n        tree.dispose()\n      }\n    }\n\n    if (options.immediate) {\n      updateCallback(stateCallback(this.state as any))\n    }\n\n    return disposer\n  }\n  addMutationListener = (cb: IMutationCallback) => {\n    return this.proxyStateTree.onMutation(cb)\n  }\n  addFlushListener = (cb: IFlushCallback) => {\n    return this.proxyStateTree.onFlush(cb)\n  }\n  reconfigure(configuration: IConfiguration) {\n    const mergedConfiguration = {\n      ...configuration,\n      state: mergeState(\n        this.originalConfiguration.state,\n        this.state,\n        configuration.state\n      ),\n    }\n    const proxyStateTree = this.proxyStateTree as any\n    this.originalConfiguration.state = configuration.state\n    this.proxyStateTree.sourceState = this.getState(mergedConfiguration)\n    proxyStateTree.createTrackStateProxifier()\n    this.state = this.proxyStateTree.state as any\n    this.actions = this.getActions(mergedConfiguration.actions)\n    this.effects = mergedConfiguration.effects || {}\n\n    this.proxyStateTree.forceFlush()\n\n    if (this.devtools) {\n      this.devtools.send({\n        type: 're_init',\n        data: {\n          state: proxyStateTree.state,\n          actions: getActionPaths(configuration.actions),\n        },\n      })\n    }\n\n    return this\n  }\n}\n\n/*\n  OPERATORS\n  needs to be in this file for typing override to work\n*/\nexport type Operator<Input = void, Output = Input> = IOperator<\n  Config,\n  Input,\n  Output\n>\n\nexport function pipe<ThisConfig extends IConfiguration, A, B, Output = B>(\n  aOperator: IOperator<ThisConfig, A, B>\n): IOperator<ThisConfig, A, Output>\n\nexport function pipe<ThisConfig extends IConfiguration, A, B, C, Output = C>(\n  aOperator: IOperator<ThisConfig, A, B>,\n  bOperator: IOperator<ThisConfig, B, C>\n): IOperator<ThisConfig, A, Output>\n\nexport function pipe<ThisConfig extends IConfiguration, A, B, C, D, Output = D>(\n  aOperator: IOperator<ThisConfig, A, B>,\n  bOperator: IOperator<ThisConfig, B, C>,\n  cOperator: IOperator<ThisConfig, C, D>\n): IOperator<ThisConfig, A, Output>\n\nexport function pipe<\n  ThisConfig extends IConfiguration,\n  A,\n  B,\n  C,\n  D,\n  E,\n  Output = E\n>(\n  aOperator: IOperator<ThisConfig, A, B>,\n  bOperator: IOperator<ThisConfig, B, C>,\n  cOperator: IOperator<ThisConfig, C, D>,\n  dOperator: IOperator<ThisConfig, D, E>\n): IOperator<ThisConfig, A, Output>\n\nexport function pipe<\n  ThisConfig extends IConfiguration,\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n  Output = F\n>(\n  aOperator: IOperator<ThisConfig, A, B>,\n  bOperator: IOperator<ThisConfig, B, C>,\n  cOperator: IOperator<ThisConfig, C, D>,\n  dOperator: IOperator<ThisConfig, D, E>,\n  eOperator: IOperator<ThisConfig, E, F>\n): IOperator<ThisConfig, A, Output>\n\nexport function pipe<\n  ThisConfig extends IConfiguration,\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n  G,\n  Output = G\n>(\n  aOperator: IOperator<ThisConfig, A, B>,\n  bOperator: IOperator<ThisConfig, B, C>,\n  cOperator: IOperator<ThisConfig, C, D>,\n  dOperator: IOperator<ThisConfig, D, E>,\n  eOperator: IOperator<ThisConfig, E, F>,\n  fOperator: IOperator<ThisConfig, F, G>\n): IOperator<ThisConfig, A, Output>\n\nexport function pipe<\n  ThisConfig extends IConfiguration,\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n  G,\n  H,\n  Output = H\n>(\n  aOperator: IOperator<ThisConfig, A, B>,\n  bOperator: IOperator<ThisConfig, B, C>,\n  cOperator: IOperator<ThisConfig, C, D>,\n  dOperator: IOperator<ThisConfig, D, E>,\n  eOperator: IOperator<ThisConfig, E, F>,\n  fOperator: IOperator<ThisConfig, F, G>,\n  gOperator: IOperator<ThisConfig, G, H>\n): IOperator<ThisConfig, A, Output>\n\nexport function pipe<\n  ThisConfig extends IConfiguration,\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n  G,\n  H,\n  I\n>(\n  aOperator: IOperator<ThisConfig, A, B>,\n  bOperator: IOperator<ThisConfig, B, C>,\n  cOperator: IOperator<ThisConfig, C, D>,\n  dOperator: IOperator<ThisConfig, D, E>,\n  eOperator: IOperator<ThisConfig, E, F>,\n  fOperator: IOperator<ThisConfig, F, G>,\n  gOperator: IOperator<ThisConfig, G, H>,\n  hOperator: IOperator<ThisConfig, H, I>\n): IOperator<ThisConfig, A, I extends never ? any : I>\n\nexport function pipe<\n  ThisConfig extends IConfiguration,\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n  G,\n  H,\n  I,\n  J\n>(\n  aOperator: IOperator<ThisConfig, A, B>,\n  bOperator: IOperator<ThisConfig, B, C>,\n  cOperator: IOperator<ThisConfig, C, D>,\n  dOperator: IOperator<ThisConfig, D, E>,\n  eOperator: IOperator<ThisConfig, E, F>,\n  fOperator: IOperator<ThisConfig, F, G>,\n  gOperator: IOperator<ThisConfig, G, H>,\n  hOperator: IOperator<ThisConfig, H, I>,\n  iOperator: IOperator<ThisConfig, I, J>\n): IOperator<ThisConfig, A, J extends never ? any : J>\n\nexport function pipe<\n  ThisConfig extends IConfiguration,\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n  G,\n  H,\n  I,\n  J,\n  K\n>(\n  aOperator: IOperator<ThisConfig, A, B>,\n  bOperator: IOperator<ThisConfig, B, C>,\n  cOperator: IOperator<ThisConfig, C, D>,\n  dOperator: IOperator<ThisConfig, D, E>,\n  eOperator: IOperator<ThisConfig, E, F>,\n  fOperator: IOperator<ThisConfig, F, G>,\n  gOperator: IOperator<ThisConfig, G, H>,\n  hOperator: IOperator<ThisConfig, H, I>,\n  iOperator: IOperator<ThisConfig, I, J>,\n  jOperator: IOperator<ThisConfig, J, K>\n): IOperator<ThisConfig, A, K extends never ? any : K>\n\nexport function pipe(...operators) {\n  const instance = (err, context, next, final = next) => {\n    if (err) next(err, context)\n    else {\n      let operatorIndex = 0\n\n      const run = (operatorErr, operatorContext) => {\n        const operator = operators[operatorIndex++]\n\n        try {\n          ;(operator || next)(operatorErr, operatorContext, run, final)\n        } catch (operatorError) {\n          ;(operator || next)(operatorError, operatorContext, run, final)\n        }\n      }\n\n      run(null, context)\n    }\n  }\n  instance[IS_OPERATOR] = true\n  return instance\n}\n\n/*\n  OPERATORS\n*/\nexport function forEach<\n  Input extends any[],\n  ThisConfig extends IConfiguration = Config\n>(\n  forEachItemOperator: IOperator<\n    ThisConfig,\n    Input extends Array<infer U> ? U : never\n  >\n): IOperator<ThisConfig, Input, Input> {\n  const instance = (err, context, next) => {\n    if (err) next(err, context)\n    else {\n      let array = context.value\n      let evaluatingCount = array.length\n      let lastContext\n      let hasErrored = false\n      const evaluate = (err) => {\n        if (hasErrored) {\n          return\n        }\n        if (err) {\n          hasErrored = true\n          return next(err)\n        }\n        evaluatingCount--\n\n        if (!evaluatingCount) {\n          operatorStopped(context, context.value)\n          next(\n            null,\n            createContext(\n              lastContext,\n              context.value,\n              lastContext.execution.path &&\n                lastContext.execution.path.slice(\n                  0,\n                  lastContext.execution.path.length - 1\n                )\n            )\n          )\n        }\n      }\n      operatorStarted('forEach', '', context)\n\n      if (array.length) {\n        array.forEach((value, index) => {\n          lastContext = createContext(\n            lastContext || context,\n            value,\n            context.execution.path &&\n              context.execution.path.concat(String(index))\n          )\n          const nextWithPath = createNextPath(evaluate)\n          // @ts-ignore\n          forEachItemOperator(null, lastContext, nextWithPath)\n        })\n      } else {\n        operatorStopped(context, context.value)\n        next(null, createContext(context, context.value))\n      }\n    }\n  }\n  instance[IS_OPERATOR] = true\n\n  return instance as any\n}\n\nexport function parallel<Input, ThisConfig extends IConfiguration = Config>(\n  ...operators: IOperator<ThisConfig, Input>[]\n): IOperator<ThisConfig, Input, Input> {\n  const instance = (err, context, next) => {\n    if (err) next(err, context)\n    else {\n      let evaluatingCount = operators.length\n      let lastContext\n      let hasErrored = false\n      const evaluate = (err) => {\n        if (hasErrored) {\n          return\n        }\n        if (err) {\n          hasErrored = true\n          return next(err, lastContext)\n        }\n        evaluatingCount--\n\n        if (!evaluatingCount) {\n          operatorStopped(context, context.value)\n          next(\n            null,\n            createContext(\n              lastContext,\n              context.value,\n              lastContext.execution.path &&\n                lastContext.execution.path.slice(\n                  0,\n                  lastContext.execution.path.length - 1\n                )\n            )\n          )\n        }\n      }\n      operatorStarted('parallel', '', context)\n\n      operators.forEach((operator, index) => {\n        lastContext = createContext(\n          lastContext || context,\n          context.value,\n          context.execution.path && context.execution.path.concat(String(index))\n        )\n        const nextWithPath = createNextPath(evaluate)\n        // @ts-ignore\n        operator(null, lastContext, nextWithPath)\n      })\n    }\n  }\n  instance[IS_OPERATOR] = true\n\n  return instance as any\n}\n\nexport function map<Input, Output, ThisConfig extends IConfiguration = Config>(\n  operation: (context: IContext<ThisConfig>, value: Input) => Output\n): IOperator<ThisConfig, Input, Output extends Promise<infer U> ? U : Output> {\n  return createOperator<ThisConfig>(\n    'map',\n    getFunctionName(operation),\n    (err, context, value, next) => {\n      if (err) next(err, value)\n      else next(null, operation(context, value))\n    }\n  )\n}\n\nexport function noop<\n  Input,\n  ThisConfig extends IConfiguration = Config\n>(): IOperator<ThisConfig, Input> {\n  return createOperator<ThisConfig>('noop', '', (err, context, value, next) => {\n    if (err) next(err, value)\n    else next(null, value)\n  })\n}\n\nexport function filter<Input, ThisConfig extends IConfiguration = Config>(\n  operation: (context: IContext<ThisConfig>, value: Input) => boolean\n): IOperator<ThisConfig, Input, Input> {\n  return createOperator<ThisConfig>(\n    'filter',\n    getFunctionName(operation),\n    (err, context, value, next, final) => {\n      if (err) next(err, value)\n      else if (operation(context, value)) next(null, value)\n      else final(null, value)\n    }\n  )\n}\n\nlet hasShownActionDeprecation = false\nexport function action<Input, ThisConfig extends IConfiguration = Config>(\n  operation: (context: IContext<ThisConfig>, value: Input) => void\n): IOperator<ThisConfig, Input, Input> {\n  if (!hasShownActionDeprecation) {\n    console.warn(\n      `DEPRECATION - The action operator is deprecated in favor of \"mutate\". The reason is to avoid confusion between actions and operators. Check out action \"${getFunctionName(\n        operation\n      )}\"`\n    )\n    hasShownActionDeprecation = true\n  }\n\n  return createMutationOperator<ThisConfig>(\n    'action',\n    getFunctionName(operation),\n    (err, context, value, next) => {\n      if (err) next(err, value)\n      else {\n        const result = operation(context, value) as any\n\n        if (isPromise(result)) {\n          next(null, result.then(() => value))\n        } else {\n          next(null, value)\n        }\n      }\n    }\n  )\n}\n\nexport function mutate<Input, ThisConfig extends IConfiguration = Config>(\n  operation: (context: IContext<ThisConfig>, value: Input) => void\n): IOperator<ThisConfig, Input, Input> {\n  return createMutationOperator<ThisConfig>(\n    'mutate',\n    getFunctionName(operation),\n    (err, context, value, next) => {\n      if (err) next(err, value)\n      else {\n        const result = operation(context, value) as any\n\n        if (isPromise(result)) {\n          next(null, result.then(() => value))\n        } else {\n          next(null, value)\n        }\n      }\n    }\n  )\n}\n\nexport function run<Input, ThisConfig extends IConfiguration = Config>(\n  operation: (context: IContext<ThisConfig>, value: Input) => void\n): IOperator<ThisConfig, Input, Input> {\n  return createOperator<ThisConfig>(\n    'run',\n    getFunctionName(operation),\n    (err, context, value, next) => {\n      if (err) next(err, value)\n      else {\n        const result = operation(context, value) as any\n\n        if (isPromise(result)) {\n          next(null, result.then(() => value))\n        } else {\n          next(null, value)\n        }\n      }\n    }\n  )\n}\n\nexport function catchError<Input, ThisConfig extends IConfiguration = Config>(\n  operation: (context: IContext<ThisConfig>, value: Error) => Input\n): IOperator<ThisConfig, Input, Input> {\n  return createMutationOperator<ThisConfig>(\n    'catchError',\n    getFunctionName(operation),\n    (err, context, value, next) => {\n      if (err) next(null, operation(context, err))\n      else\n        next(null, value, {\n          isSkipped: true,\n        })\n    }\n  )\n}\n\nexport function tryCatch<\n  Input,\n  ThisConfig extends IConfiguration = Config\n>(paths: {\n  try: IOperator<ThisConfig, Input>\n  catch: IOperator<ThisConfig, Error>\n}): IOperator<ThisConfig, Input, Input> {\n  const instance = (err, context, next) => {\n    if (err) next(err, context)\n    else {\n      const evaluateCatch = (err, catchContext) => {\n        operatorStopped(context, context.value)\n        next(err, createContext(catchContext, context.value))\n      }\n      const evaluateTry = (err, tryContext) => {\n        if (err) {\n          const newContext = createContext(\n            tryContext,\n            err,\n            context.execution.path && context.execution.path.concat('catch')\n          )\n          const nextWithPath = createNextPath(evaluateCatch)\n\n          // @ts-ignore\n          paths.catch(null, newContext, nextWithPath)\n        } else {\n          operatorStopped(context, context.value)\n          next(null, createContext(tryContext, context.value))\n        }\n      }\n\n      operatorStarted('tryCatch', '', context)\n\n      const newContext = createContext(\n        context,\n        context.value,\n        context.execution.path && context.execution.path.concat('try')\n      )\n      const nextWithPath = createNextPath(evaluateTry)\n\n      // @ts-ignore\n      paths.try(null, newContext, nextWithPath)\n    }\n  }\n  instance[IS_OPERATOR] = true\n\n  return instance as any\n}\n\nexport function fork<\n  Input,\n  Paths extends { [key: string]: IOperator<ThisConfig, any, any> },\n  ThisConfig extends IConfiguration = Config\n>(\n  operation: (context: IContext<ThisConfig>, value: Input) => keyof Paths,\n  paths: Paths & { [N in keyof Paths]: IOperator<ThisConfig, Input, any> }\n): IOperator<ThisConfig, Input, Input> {\n  return createOperator<ThisConfig>(\n    'fork',\n    getFunctionName(operation),\n    (err, context, value, next) => {\n      if (err) next(err, value)\n      else {\n        const path = operation(context, value)\n        next(null, value, {\n          path: {\n            name: String(path),\n            operator: paths[path],\n          },\n        })\n      }\n    }\n  )\n}\n\nexport function when<\n  Input,\n  OutputA,\n  OutputB,\n  ThisConfig extends IConfiguration = Config\n>(\n  operation: (context: IContext<ThisConfig>, value: Input) => boolean,\n  paths: {\n    true: IOperator<ThisConfig, Input, OutputA>\n    false: IOperator<ThisConfig, Input, OutputB>\n  }\n): IOperator<ThisConfig, Input, OutputA | OutputB> {\n  return createOperator<ThisConfig>(\n    'when',\n    getFunctionName(operation),\n    (err, context, value, next) => {\n      if (err) next(err, value)\n      else if (operation(context, value))\n        next(null, value, {\n          path: {\n            name: 'true',\n            operator: paths.true,\n          },\n        })\n      else\n        next(null, value, {\n          path: {\n            name: 'false',\n            operator: paths.false,\n          },\n        })\n    }\n  )\n}\n\nexport function wait<Input, ThisConfig extends IConfiguration = Config>(\n  ms: number\n): IOperator<ThisConfig, Input, Input> {\n  return createOperator('wait', String(ms), (err, context, value, next) => {\n    if (err) next(err, value)\n    else setTimeout(() => next(null, value), ms)\n  })\n}\n\nexport function debounce<Input, ThisConfig extends IConfiguration = Config>(\n  ms: number\n): IOperator<ThisConfig, Input, Input> {\n  let timeout\n  let previousFinal\n\n  return createOperator(\n    'debounce',\n    String(ms),\n    (err, context, value, next, final) => {\n      if (err) next(err, value)\n      else {\n        if (timeout) {\n          clearTimeout(timeout)\n          previousFinal(null, value)\n        }\n        previousFinal = final\n        timeout = setTimeout(() => {\n          timeout = null\n          next(null, value)\n        }, ms)\n      }\n    }\n  )\n}\n\nexport function throttle<Input, ThisConfig extends IConfiguration = Config>(\n  ms: number\n): IOperator<ThisConfig, Input, Input> {\n  let timeout\n  let previousFinal\n  let currentNext\n\n  return createOperator(\n    'throttle',\n    String(ms),\n    (err, context, value, next, final) => {\n      if (err) next(err, value)\n      else {\n        if (timeout) {\n          previousFinal(null, value)\n          currentNext = next\n        } else {\n          timeout = setTimeout(() => {\n            timeout = null\n            currentNext(null, value)\n          }, ms)\n        }\n        previousFinal = final\n        currentNext = next\n      }\n    }\n  )\n}\n\nexport function waitUntil<Input, ThisConfig extends IConfiguration = Config>(\n  operation: (state: ThisConfig['state']) => boolean\n): IOperator<ThisConfig, Input, Input> {\n  return createOperator<Config>(\n    'waitUntil',\n    operation.name,\n    (err, context, value, next) => {\n      if (err) next(err, value)\n      else {\n        const tree = context.execution.getTrackStateTree()\n        const test = () => {\n          if (operation(tree.state)) {\n            tree.dispose()\n            next(null, value)\n          }\n        }\n        tree.trackScope(test, test)\n      }\n    }\n  )\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}