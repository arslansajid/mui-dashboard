{"ast":null,"code":"import dayjs from 'dayjs';\nimport { historical } from 'config';\n\nconst getY = (value, type) => {\n  if (!value) return 0;\n\n  switch (type) {\n    case 'linear':\n      return value;\n\n    case 'log':\n      return Math.log(value);\n\n    case 'log10':\n      return Math.log10(value);\n\n    default:\n      return value;\n  }\n};\n\nfunction correctUSData(us) {\n  if (us.active === 0) {\n    return { ...us,\n      active: us.confirmed - us.deaths - us.recovered\n    };\n  }\n\n  return us;\n}\n\nconst dataCorrection = data => {\n  return data.map(country => country.countryRegion === 'US' ? correctUSData(country) : country);\n};\n\nconst convertToLineChartData = (data, type = 'linear') => data.reduce((acc, item) => {\n  acc[0].data.push({\n    x: item.reportDate,\n    y: getY(item.deaths.total, type)\n  });\n  acc[1].data.push({\n    x: item.reportDate,\n    y: getY(item.confirmed.total, type)\n  });\n  return acc;\n}, [{\n  id: 'Deaths',\n  data: []\n}, {\n  id: 'Confirmed',\n  data: []\n}]);\n\nconst getLineChartData = (data, criterion, type, date) => {\n  return {\n    x: (date ? dayjs(date, historical.dates.format) : dayjs(data.lastUpdate)).format(historical.dates.lineChartFormat),\n    y: getY(data[criterion], type)\n  };\n};\n\nconst convertHistoricalToLineChartData = (data, type = 'linear', criterion, selected, currentDate) => {\n  const dates = Object.keys(data);\n  const selectedDates = dates.slice(0, dates.indexOf(currentDate));\n  return Object.entries(data).reduce((acc, [date, item]) => {\n    item && item.forEach(daily => {\n      if (selected.includes(daily.countryRegion) && selectedDates.includes(date)) {\n        const country = acc.find(bl => bl.id === daily.countryRegion);\n\n        if (country) {\n          country.data.push(getLineChartData(daily, criterion, type, date));\n        } else {\n          acc.push({\n            id: daily.countryRegion,\n            data: [getLineChartData(daily, criterion, type, date)]\n          });\n        }\n      }\n    });\n    return acc;\n  }, []);\n};\n\nconst convertToPieChartData = (data, criterion) => {\n  const _data = dataCorrection(data, 'pie chart');\n\n  const sortedData = criterion === 'confirmed' ? _data : [..._data].sort((a, b) => b[criterion] - a[criterion]);\n  const top10 = sortedData.filter(item => !item.provinceState).slice(0, 10);\n  return top10.map(item => ({\n    id: item.countryRegion,\n    label: item.countryRegion,\n    value: item[criterion]\n  }));\n};\n\nconst generateDataRange = (from, to, format, isArray) => {\n  let dates = {};\n  const max = to;\n  let current = from;\n\n  while (current.isBefore(max) && Object.keys(dates).length < 2000) {\n    dates[current.format(format)] = undefined;\n    current = current.add(1, 'days');\n  }\n\n  return isArray ? Object.keys(dates) : dates;\n};\n\nexport { convertToLineChartData, convertToPieChartData, dataCorrection, convertHistoricalToLineChartData, generateDataRange };","map":{"version":3,"sources":["/Users/arslansajid/Documents/Github/corona/covid19-client/src/utils/convert.js"],"names":["dayjs","historical","getY","value","type","Math","log","log10","correctUSData","us","active","confirmed","deaths","recovered","dataCorrection","data","map","country","countryRegion","convertToLineChartData","reduce","acc","item","push","x","reportDate","y","total","id","getLineChartData","criterion","date","dates","format","lastUpdate","lineChartFormat","convertHistoricalToLineChartData","selected","currentDate","Object","keys","selectedDates","slice","indexOf","entries","forEach","daily","includes","find","bl","convertToPieChartData","_data","sortedData","sort","a","b","top10","filter","provinceState","label","generateDataRange","from","to","isArray","max","current","isBefore","length","undefined","add"],"mappings":"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","sourcesContent":["import dayjs from 'dayjs';\n\nimport { historical } from 'config';\n\nconst getY = (value, type) => {\n  if (!value) return 0;\n\n  switch(type) {\n    case 'linear': return value;\n    case 'log': return Math.log(value);\n    case 'log10': return Math.log10(value);\n    default: return value;\n  }\n};\n\nfunction correctUSData(us) {\n  if (us.active === 0) {\n    return { ...us, active: us.confirmed - us.deaths - us.recovered }\n  }\n\n  return us;\n}\n\nconst dataCorrection = data => {\n  return data.map(country => country.countryRegion === 'US' ? correctUSData(country) : country);\n};\n\nconst convertToLineChartData = (data, type = 'linear') => data.reduce((acc, item) => {\n  acc[0].data.push({ x: item.reportDate, y: getY(item.deaths.total, type) });\n  acc[1].data.push({ x: item.reportDate, y: getY(item.confirmed.total, type) });\n\n  return acc;\n}, [{ id: 'Deaths', data: [] }, { id: 'Confirmed', data: [] }]);\n\nconst getLineChartData = (data, criterion, type, date) => {\n  return {\n    x: (date ? dayjs(date, historical.dates.format) : dayjs(data.lastUpdate))\n      .format(historical.dates.lineChartFormat),\n    y: getY(data[criterion], type),\n  };\n};\n\nconst convertHistoricalToLineChartData = (data, type = 'linear', criterion, selected, currentDate) => {\n  const dates = Object.keys(data);\n  const selectedDates = dates.slice(0, dates.indexOf(currentDate));\n\n  return Object.entries(data).reduce((acc, [date, item]) => {\n    item && item.forEach(daily => {\n      if (selected.includes(daily.countryRegion) && selectedDates.includes(date)) {\n        const country = acc.find(bl => bl.id === daily.countryRegion);\n\n        if (country) {\n          country.data.push(getLineChartData(daily, criterion, type, date));\n        } else {\n          acc.push({ id: daily.countryRegion, data: [getLineChartData(daily, criterion, type, date)] })\n        }\n      }\n    });\n\n    return acc;\n  }, []);\n};\n\nconst convertToPieChartData = (data, criterion) => {\n  const _data = dataCorrection(data, 'pie chart');\n\n  const sortedData = criterion === 'confirmed'\n    ? _data\n    : [..._data].sort((a, b) => b[criterion] - a[criterion]);\n\n  const top10 = sortedData.filter(item => !item.provinceState).slice(0, 10);\n\n  return top10.map(item => ({\n    id: item.countryRegion,\n    label: item.countryRegion,\n    value: item[criterion],\n  }));\n};\n\nconst generateDataRange = (from, to, format, isArray) => {\n  let dates = {};\n  const max = to;\n  let current = from;\n\n  while(current.isBefore(max) && (Object.keys(dates).length < 2000)) {\n    dates[current.format(format)] = undefined;\n    current = current.add(1, 'days');\n  }\n\n  return isArray ? Object.keys(dates) : dates;\n};\n\nexport {\n  convertToLineChartData,\n  convertToPieChartData,\n  dataCorrection,\n  convertHistoricalToLineChartData,\n  generateDataRange,\n};\n"]},"metadata":{},"sourceType":"module"}