{"ast":null,"code":"import 'proxy-state-tree';\nimport { EventType, MODE_SSR } from 'overmind';\nimport * as react from 'react';\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production';\nconst IS_TEST = process.env.NODE_ENV === 'test';\nconst isNode = !IS_TEST && process && process.title && process.title.includes('node');\n\nfunction throwMissingContextError() {\n  throw new Error('The Overmind hook could not find an Overmind instance on the context of React. Please make sure you use the Provider component at the top of your application and expose the Overmind instance there. Please read more in the React guide on the website');\n}\n\nconst context = react.createContext({});\nlet nextComponentId = 0;\nexport const Provider = context.Provider;\nexport const createHook = () => {\n  let currentComponentInstanceId = 0;\n  const {\n    ReactCurrentOwner\n  } = react.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n  const useCurrentComponent = () => {\n    return ReactCurrentOwner && ReactCurrentOwner.current && ReactCurrentOwner.current.elementType ? ReactCurrentOwner.current.elementType : {};\n  };\n\n  const useForceRerender = () => {\n    const [flushId, setState] = react.useState(() => -1); // We use memo here, instead of ref, to support fast-refresh\n\n    const mountedRef = react.useMemo(() => ({\n      current: true\n    }), []);\n    react.useEffect(() => () => {\n      mountedRef.current = false;\n    }, []);\n\n    const forceRerender = (_, __, flushId) => {\n      if (mountedRef.current) {\n        setState(flushId);\n      }\n    };\n\n    return {\n      forceRerender,\n      flushId\n    };\n  };\n\n  return () => {\n    const overmind = react.useContext(context);\n\n    if (!overmind.mode) {\n      throwMissingContextError();\n    }\n\n    if (isNode || overmind.mode.mode === MODE_SSR) {\n      return {\n        state: overmind.state,\n        actions: overmind.actions,\n        effects: overmind.effects,\n        addMutationListener: overmind.addMutationListener,\n        reaction: overmind.reaction\n      };\n    }\n\n    const tree = react.useMemo(() => overmind.proxyStateTree.getTrackStateTree(), []);\n\n    if (IS_PRODUCTION) {\n      const {\n        forceRerender\n      } = useForceRerender();\n      react.useEffect(() => () => {\n        ;\n        overmind.proxyStateTree.disposeTree(tree);\n      }, []);\n      react.useLayoutEffect(() => tree.stopTracking());\n      tree.track(forceRerender);\n    } else {\n      const component = useCurrentComponent();\n      const name = component.name;\n      component.__componentId = typeof component.__componentId === 'undefined' ? nextComponentId++ : component.__componentId;\n      const {\n        current: componentInstanceId\n      } = react.useRef(currentComponentInstanceId++);\n      const {\n        flushId,\n        forceRerender\n      } = useForceRerender();\n      react.useLayoutEffect(() => {\n        overmind.eventHub.emitAsync(EventType.COMPONENT_ADD, {\n          componentId: component.__componentId,\n          componentInstanceId,\n          name,\n          paths: Array.from(tree.pathDependencies)\n        });\n        return () => {\n          ;\n          overmind.proxyStateTree.disposeTree(tree);\n          overmind.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {\n            componentId: component.__componentId,\n            componentInstanceId,\n            name\n          });\n        };\n      }, []);\n      react.useLayoutEffect(() => {\n        tree.stopTracking();\n        overmind.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {\n          componentId: component.__componentId,\n          componentInstanceId,\n          name,\n          flushId,\n          paths: Array.from(tree.pathDependencies)\n        });\n      });\n      tree.track(forceRerender);\n    }\n\n    const suspend = cb => {\n      const value = cb();\n\n      if (value === null || value === undefined) {\n        ;\n        overmind.proxyStateTree.disposeTree(tree);\n        throw new Promise(resolve => {\n          const dispose = overmind.addFlushListener(() => {\n            const newValue = cb();\n\n            if (newValue === null || newValue === undefined) {\n              return;\n            }\n\n            dispose();\n            resolve();\n          });\n        });\n      }\n\n      return value;\n    };\n\n    return {\n      state: tree.state,\n      actions: overmind.actions,\n      effects: overmind.effects,\n      addMutationListener: overmind.addMutationListener,\n      reaction: overmind.reaction,\n      suspend\n    };\n  };\n};\nexport const createConnect = () => {\n  return component => {\n    let componentInstanceId = 0;\n    const name = component.name;\n    const populatedComponent = component;\n    populatedComponent.__componentId = typeof populatedComponent.__componentId === 'undefined' ? nextComponentId++ : populatedComponent.__componentId;\n    const isClassComponent = component.prototype && typeof component.prototype.render === 'function';\n\n    if (isClassComponent) {\n      const originalRender = component.prototype.render;\n\n      component.prototype.render = function () {\n        if (this.props.overmind) {\n          return this.props.overmind.tree.trackScope(() => originalRender.call(this), this.props.overmind.onUpdate);\n        }\n\n        return originalRender.call(this);\n      };\n    }\n\n    if (IS_PRODUCTION) {\n      class HOC extends react.Component {\n        constructor(props, context) {\n          super(props);\n\n          this.onUpdate = () => {\n            this.setState({\n              overmind: {\n                state: this.tree.state,\n                effects: this.overmind.effects,\n                actions: this.overmind.actions,\n                addMutationListener: this.overmind.addMutationListener,\n                onUpdate: this.onUpdate,\n                tree: this.tree,\n                reaction: this.overmind.reaction\n              }\n            });\n          };\n\n          if (!context) {\n            throwMissingContextError();\n          }\n\n          this.overmind = context;\n          this.tree = this.overmind.proxyStateTree.getTrackStateTree();\n          this.state = {\n            overmind: {\n              state: this.tree.state,\n              effects: this.overmind.effects,\n              actions: this.overmind.actions,\n              addMutationListener: this.overmind.addMutationListener,\n              onUpdate: this.onUpdate,\n              tree: this.tree,\n              reaction: this.overmind.reaction\n            }\n          };\n\n          this.wrappedComponent = (...args) => this.tree.trackScope(() => component(...args), this.onUpdate);\n        }\n\n        componentWillUnmount() {\n          this.overmind.proxyStateTree.disposeTree(this.tree);\n        }\n\n        render() {\n          if (isClassComponent) {\n            return react.createElement(component, Object.assign(Object.assign({}, this.props), {\n              overmind: this.state.overmind\n            }));\n          }\n\n          return react.createElement(this.wrappedComponent, Object.assign(Object.assign({}, this.props), {\n            overmind: this.state.overmind\n          }));\n        }\n\n      }\n\n      HOC.contextType = context;\n      return HOC;\n    } else {\n      class HOC extends react.Component {\n        constructor(props, context) {\n          super(props);\n          this.componentInstanceId = componentInstanceId++;\n          this.currentFlushId = 0;\n\n          this.onUpdate = (mutatons, paths, flushId) => {\n            this.currentFlushId = flushId;\n            this.isUpdating = true;\n            this.setState({\n              overmind: {\n                state: this.tree.state,\n                effects: this.overmind.effects,\n                actions: this.overmind.actions,\n                addMutationListener: this.overmind.addMutationListener,\n                onUpdate: this.onUpdate,\n                tree: this.tree,\n                reaction: this.overmind.reaction\n              }\n            });\n          };\n\n          if (!context) {\n            throwMissingContextError();\n          }\n\n          this.overmind = context;\n          this.tree = this.overmind.proxyStateTree.getTrackStateTree();\n          this.state = {\n            overmind: {\n              state: this.tree.state,\n              effects: this.overmind.effects,\n              actions: this.overmind.actions,\n              addMutationListener: this.overmind.addMutationListener,\n              onUpdate: this.onUpdate,\n              tree: this.tree,\n              reaction: this.overmind.reaction\n            }\n          };\n\n          this.wrappedComponent = (...args) => this.tree.trackScope(() => component(...args), this.onUpdate);\n        }\n\n        componentDidMount() {\n          this.overmind.eventHub.emitAsync(EventType.COMPONENT_ADD, {\n            componentId: populatedComponent.__componentId,\n            componentInstanceId: this.componentInstanceId,\n            name,\n            paths: Array.from(this.tree.pathDependencies)\n          });\n        }\n\n        componentDidUpdate() {\n          if (this.isUpdating) {\n            this.overmind.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {\n              componentId: populatedComponent.__componentId,\n              componentInstanceId: this.componentInstanceId,\n              name,\n              flushId: this.currentFlushId,\n              paths: Array.from(this.tree.pathDependencies)\n            });\n            this.isUpdating = false;\n          }\n        }\n\n        componentWillUnmount() {\n          this.overmind.proxyStateTree.disposeTree(this.tree);\n          this.overmind.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {\n            componentId: populatedComponent.__componentId,\n            componentInstanceId: this.componentInstanceId,\n            name\n          });\n        }\n\n        render() {\n          if (isClassComponent) {\n            return react.createElement(component, Object.assign(Object.assign({}, this.props), {\n              overmind: this.state.overmind\n            }));\n          }\n\n          return react.createElement(this.wrappedComponent, Object.assign(Object.assign({}, this.props), {\n            overmind: this.state.overmind\n          }));\n        }\n\n      }\n\n      HOC.contextType = context;\n      Object.defineProperties(HOC, {\n        name: {\n          value: 'Connect' + (component.displayName || component.name || '')\n        }\n      });\n      return HOC;\n    }\n  };\n};","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import 'proxy-state-tree'\n\nimport {\n  EventType,\n  IConfiguration,\n  MODE_SSR,\n  Overmind,\n  OvermindMock,\n} from 'overmind'\nimport { IMutationCallback } from 'proxy-state-tree'\nimport * as react from 'react'\n\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\nconst IS_TEST = process.env.NODE_ENV === 'test'\nconst isNode =\n  !IS_TEST && process && process.title && process.title.includes('node')\n\nexport type IReactComponent<P = any> =\n  | react.StatelessComponent<P>\n  | react.ComponentClass<P>\n  | react.ClassicComponentClass<P>\n\n// Diff / Omit taken from https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-311923766\ntype Omit<T, K extends keyof T> = Pick<\n  T,\n  ({ [P in keyof T]: P } &\n    { [P in K]: never } & { [x: string]: never; [x: number]: never })[keyof T]\n>\n\nexport interface IConnect<Config extends IConfiguration> {\n  overmind: {\n    state: Overmind<Config>['state']\n    actions: Overmind<Config>['actions']\n    effects: Overmind<Config>['effects']\n    addMutationListener: Overmind<Config>['addMutationListener']\n    reaction: Overmind<Config>['reaction']\n    suspend: <T>(cb: () => T) => T\n  }\n}\n\nfunction throwMissingContextError() {\n  throw new Error(\n    'The Overmind hook could not find an Overmind instance on the context of React. Please make sure you use the Provider component at the top of your application and expose the Overmind instance there. Please read more in the React guide on the website'\n  )\n}\n\nconst context = react.createContext<Overmind<IConfiguration>>({} as Overmind<\n  IConfiguration\n>)\nlet nextComponentId = 0\n\nexport const Provider: React.ProviderExoticComponent<\n  React.ProviderProps<Overmind<IConfiguration> | OvermindMock<IConfiguration>>\n> = context.Provider\n\nexport const createHook = <Config extends IConfiguration>(): (() => {\n  state: Overmind<Config>['state']\n  actions: Overmind<Config>['actions']\n  effects: Overmind<Config>['effects']\n  addMutationListener: (cb: IMutationCallback) => () => void\n  reaction: Overmind<Config>['reaction']\n}) => {\n  let currentComponentInstanceId = 0\n  const {\n    ReactCurrentOwner,\n  } = (react as any).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n  const useCurrentComponent = () => {\n    return ReactCurrentOwner &&\n      ReactCurrentOwner.current &&\n      ReactCurrentOwner.current.elementType\n      ? ReactCurrentOwner.current.elementType\n      : {}\n  }\n  const useForceRerender = () => {\n    const [flushId, setState] = react.useState(() => -1)\n    // We use memo here, instead of ref, to support fast-refresh\n    const mountedRef = react.useMemo(() => ({ current: true}), [])\n\n    react.useEffect(\n      () => () => {\n        mountedRef.current = false\n      },\n      []\n    )\n\n    const forceRerender = (_, __, flushId): void => {\n      if (mountedRef.current) {\n        setState(flushId)\n      }\n    }\n    return {\n      forceRerender,\n      flushId,\n    }\n  }\n\n  return () => {\n    const overmind = react.useContext(context) as Overmind<Config>\n\n    if (!(overmind as any).mode) {\n      throwMissingContextError()\n    }\n\n    if (isNode || (overmind as any).mode.mode === MODE_SSR) {\n      return {\n        state: overmind.state,\n        actions: overmind.actions,\n        effects: overmind.effects,\n        addMutationListener: overmind.addMutationListener,\n        reaction: overmind.reaction,\n      }\n    }\n\n    const tree = react.useMemo<any>(() =>\n      (overmind as any).proxyStateTree.getTrackStateTree(), []\n    )\n\n    if (IS_PRODUCTION) {\n      const { forceRerender } = useForceRerender()\n\n      react.useEffect(\n        () => () => {\n          ;(overmind as any).proxyStateTree.disposeTree(tree)\n        },\n        []\n      )\n\n      react.useLayoutEffect(() => tree.stopTracking())\n\n      tree.track(forceRerender)\n    } else {\n      const component = useCurrentComponent()\n      const name = component.name\n      component.__componentId =\n        typeof component.__componentId === 'undefined'\n          ? nextComponentId++\n          : component.__componentId\n\n      const { current: componentInstanceId } = react.useRef<any>(\n        currentComponentInstanceId++\n      )\n\n      const { flushId, forceRerender } = useForceRerender()\n\n      react.useLayoutEffect(() => {\n        overmind.eventHub.emitAsync(EventType.COMPONENT_ADD, {\n          componentId: component.__componentId,\n          componentInstanceId,\n          name,\n          paths: Array.from(tree.pathDependencies) as any,\n        })\n\n        return () => {\n          ;(overmind as any).proxyStateTree.disposeTree(tree)\n          overmind.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {\n            componentId: component.__componentId,\n            componentInstanceId,\n            name,\n          })\n        }\n      }, [])\n\n      react.useLayoutEffect(() => {\n        tree.stopTracking()\n        overmind.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {\n          componentId: component.__componentId,\n          componentInstanceId,\n          name,\n          flushId,\n          paths: Array.from(tree.pathDependencies) as any,\n        })\n      })\n      tree.track(forceRerender)\n    }\n\n    const suspend = (cb) => {\n      const value = cb()\n\n      if (value === null || value === undefined) {\n        ;(overmind as any).proxyStateTree.disposeTree(tree)\n\n        throw new Promise((resolve) => {\n          const dispose = overmind.addFlushListener(() => {\n            const newValue = cb()\n\n            if (newValue === null || newValue === undefined) {\n              return\n            }\n\n            dispose()\n            resolve()\n          })\n        })\n      }\n\n      return value\n    }\n\n    return {\n      state: tree.state,\n      actions: overmind.actions,\n      effects: overmind.effects,\n      addMutationListener: overmind.addMutationListener,\n      reaction: overmind.reaction,\n      suspend,\n    }\n  }\n}\n\nexport const createConnect = <ThisConfig extends IConfiguration>() => {\n  return <Props>(\n    component: IReactComponent<\n      Props & {\n        overmind: {\n          state: Overmind<ThisConfig>['state']\n          actions: Overmind<ThisConfig>['actions']\n          reaction: Overmind<ThisConfig>['reaction']\n        }\n      }\n    >\n  ): IReactComponent<\n    Omit<\n      Props & IConnect<Overmind<ThisConfig>>,\n      keyof IConnect<Overmind<ThisConfig>>\n    >\n  > => {\n    let componentInstanceId = 0\n    const name = component.name\n    const populatedComponent = component as any\n    populatedComponent.__componentId =\n      typeof populatedComponent.__componentId === 'undefined'\n        ? nextComponentId++\n        : populatedComponent.__componentId\n    const isClassComponent =\n      component.prototype && typeof component.prototype.render === 'function'\n\n    if (isClassComponent) {\n      const originalRender = component.prototype.render\n      component.prototype.render = function() {\n        if (this.props.overmind) {\n          return this.props.overmind.tree.trackScope(\n            () => originalRender.call(this),\n            this.props.overmind.onUpdate\n          )\n        }\n\n        return originalRender.call(this)\n      }\n    }\n\n    if (IS_PRODUCTION) {\n      class HOC extends react.Component {\n        tree: any\n        overmind: any\n        state: {\n          overmind: any\n        }\n        wrappedComponent: any\n        static contextType = context\n        constructor(props, context) {\n          super(props)\n\n          if (!context) {\n            throwMissingContextError()\n          }\n          this.overmind = context\n          this.tree = this.overmind.proxyStateTree.getTrackStateTree()\n          this.state = {\n            overmind: {\n              state: this.tree.state,\n              effects: this.overmind.effects,\n              actions: this.overmind.actions,\n              addMutationListener: this.overmind.addMutationListener,\n              onUpdate: this.onUpdate,\n              tree: this.tree,\n              reaction: this.overmind.reaction,\n            },\n          }\n          this.wrappedComponent = (...args) =>\n            this.tree.trackScope(\n              () => (component as any)(...args),\n              this.onUpdate\n            )\n        }\n        componentWillUnmount() {\n          this.overmind.proxyStateTree.disposeTree(this.tree)\n        }\n        onUpdate = () => {\n          this.setState({\n            overmind: {\n              state: this.tree.state,\n              effects: this.overmind.effects,\n              actions: this.overmind.actions,\n              addMutationListener: this.overmind.addMutationListener,\n              onUpdate: this.onUpdate,\n              tree: this.tree,\n              reaction: this.overmind.reaction,\n            },\n          })\n        }\n        render() {\n          if (isClassComponent) {\n            return react.createElement(component, {\n              ...this.props,\n              overmind: this.state.overmind,\n            } as any)\n          }\n\n          return react.createElement(this.wrappedComponent, {\n            ...this.props,\n            overmind: this.state.overmind,\n          } as any)\n        }\n      }\n\n      return HOC as any\n    } else {\n      class HOC extends react.Component {\n        tree: any\n        overmind: any\n        componentInstanceId = componentInstanceId++\n        currentFlushId = 0\n        state: {\n          overmind: any\n        }\n        isUpdating: boolean\n        wrappedComponent: any\n        static contextType = context\n        constructor(props, context) {\n          super(props)\n\n          if (!context) {\n            throwMissingContextError()\n          }\n\n          this.overmind = context\n          this.tree = this.overmind.proxyStateTree.getTrackStateTree()\n          this.state = {\n            overmind: {\n              state: this.tree.state,\n              effects: this.overmind.effects,\n              actions: this.overmind.actions,\n              addMutationListener: this.overmind.addMutationListener,\n              onUpdate: this.onUpdate,\n              tree: this.tree,\n              reaction: this.overmind.reaction,\n            },\n          }\n          this.wrappedComponent = (...args) =>\n            this.tree.trackScope(\n              () => (component as any)(...args),\n              this.onUpdate\n            )\n        }\n        componentDidMount() {\n          this.overmind.eventHub.emitAsync(EventType.COMPONENT_ADD, {\n            componentId: populatedComponent.__componentId,\n            componentInstanceId: this.componentInstanceId,\n            name,\n            paths: Array.from(this.tree.pathDependencies) as any,\n          })\n        }\n        componentDidUpdate() {\n          if (this.isUpdating) {\n            this.overmind.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {\n              componentId: populatedComponent.__componentId,\n              componentInstanceId: this.componentInstanceId,\n              name,\n              flushId: this.currentFlushId,\n              paths: Array.from(this.tree.pathDependencies as Set<string>),\n            })\n            this.isUpdating = false\n          }\n        }\n        componentWillUnmount() {\n          this.overmind.proxyStateTree.disposeTree(this.tree)\n          this.overmind.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {\n            componentId: populatedComponent.__componentId,\n            componentInstanceId: this.componentInstanceId,\n            name,\n          })\n        }\n        onUpdate = (mutatons, paths, flushId) => {\n          this.currentFlushId = flushId\n          this.isUpdating = true\n          this.setState({\n            overmind: {\n              state: this.tree.state,\n              effects: this.overmind.effects,\n              actions: this.overmind.actions,\n              addMutationListener: this.overmind.addMutationListener,\n              onUpdate: this.onUpdate,\n              tree: this.tree,\n              reaction: this.overmind.reaction,\n            },\n          })\n        }\n        render() {\n          if (isClassComponent) {\n            return react.createElement(component, {\n              ...this.props,\n              overmind: this.state.overmind,\n            } as any)\n          }\n          return react.createElement(this.wrappedComponent, {\n            ...this.props,\n            overmind: this.state.overmind,\n          } as any)\n        }\n      }\n\n      Object.defineProperties(HOC, {\n        name: {\n          value: 'Connect' + (component.displayName || component.name || ''),\n        },\n      })\n\n      return HOC as any\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}