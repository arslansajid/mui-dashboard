{"ast":null,"code":"import isPlainObject from 'is-plain-obj';\nimport { IS_PROXY, VALUE } from 'proxy-state-tree';\nexport const IS_TEST = process.env.NODE_ENV === 'test';\nexport const IS_OPERATOR = Symbol('operator');\nexport const ORIGINAL_ACTIONS = Symbol('origina_actions');\nexport const EXECUTION = Symbol('execution');\nexport const MODE_DEFAULT = Symbol('MODE_DEFAULT');\nexport const MODE_TEST = Symbol('MODE_TEST');\nexport const MODE_SSR = Symbol('MODE_SSR');\nexport class MockedEventEmitter {\n  emit() {}\n\n  emitAsync() {}\n\n  on() {}\n\n  once() {}\n\n  addListener() {}\n\n}\nexport const json = obj => {\n  return deepCopy(obj && obj[IS_PROXY] ? obj[VALUE] : obj);\n};\nexport function isPromise(maybePromise) {\n  return maybePromise instanceof Promise || maybePromise && typeof maybePromise.then === 'function' && typeof maybePromise.catch === 'function';\n}\nexport function processState(state) {\n  return Object.keys(state).reduce((aggr, key) => {\n    if (key === '__esModule') {\n      return aggr;\n    }\n\n    const originalDescriptor = Object.getOwnPropertyDescriptor(state, key);\n\n    if (originalDescriptor && 'get' in originalDescriptor) {\n      Object.defineProperty(aggr, key, originalDescriptor);\n      return aggr;\n    }\n\n    const value = state[key];\n\n    if (isPlainObject(value)) {\n      aggr[key] = processState(value);\n    } else {\n      Object.defineProperty(aggr, key, originalDescriptor);\n    }\n\n    return aggr;\n  }, {});\n}\nexport function getFunctionName(func) {\n  return func.name || func.displayName || '';\n}\nexport function deepCopy(obj) {\n  if (isPlainObject(obj)) {\n    return Object.keys(obj).reduce((aggr, key) => {\n      if (key === '__esModule') {\n        return aggr;\n      }\n\n      const originalDescriptor = Object.getOwnPropertyDescriptor(obj, key);\n      const isAGetter = originalDescriptor && 'get' in originalDescriptor;\n      const value = obj[key];\n\n      if (isAGetter) {\n        Object.defineProperty(aggr, key, originalDescriptor);\n      } else {\n        aggr[key] = deepCopy(value);\n      }\n\n      return aggr;\n    }, {});\n  } else if (Array.isArray(obj)) {\n    return obj.map(item => deepCopy(item));\n  }\n\n  return obj;\n}\nexport function mergeState(originState, oldState, nextState) {\n  function merge(origin, old, next) {\n    if (isPlainObject(old) && isPlainObject(next)) {\n      const newBranch = {};\n      const keys = Object.keys(old).concat(Object.keys(next));\n\n      for (let key of keys) {\n        newBranch[key] = merge(origin[key], old[key], next[key]);\n      }\n\n      return newBranch;\n    }\n\n    if (typeof next === 'function') {\n      return next;\n    } // We return the existing array, as arrays are typically\n    // mutated, not set with new values as initial state\n\n\n    if (Array.isArray(old) && Array.isArray(next)) {\n      return old;\n    } // If we have changed a state from origin, keep that\n    // changed state\n\n\n    if (next === origin && old !== origin) {\n      return old;\n    }\n\n    return next;\n  }\n\n  return merge(originState, oldState, nextState);\n}\nexport function getActionPaths(actions = {}, currentPath = []) {\n  return Object.keys(actions).reduce((aggr, key) => {\n    if (typeof actions[key] === 'function') {\n      return aggr.concat(currentPath.concat(key).join('.'));\n    }\n\n    return aggr.concat(getActionPaths(actions[key], currentPath.concat(key)));\n  }, []);\n}\nexport function createActionsProxy(actions, cb) {\n  return new Proxy(actions, {\n    get(target, prop) {\n      if (prop === ORIGINAL_ACTIONS) {\n        return actions;\n      }\n\n      if (typeof target[prop] === 'function') {\n        return cb(target[prop]);\n      }\n\n      if (!target[prop]) {\n        return undefined;\n      }\n\n      return createActionsProxy(target[prop], cb);\n    }\n\n  });\n}","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import isPlainObject from 'is-plain-obj'\nimport { IMutation, IS_PROXY, VALUE } from 'proxy-state-tree'\n\nimport { Derived } from './derived'\nimport { IState } from './types'\n\nexport const IS_TEST = process.env.NODE_ENV === 'test'\nexport const IS_OPERATOR = Symbol('operator')\nexport const ORIGINAL_ACTIONS = Symbol('origina_actions')\nexport const EXECUTION = Symbol('execution')\n\nexport const MODE_DEFAULT = Symbol('MODE_DEFAULT')\nexport const MODE_TEST = Symbol('MODE_TEST')\nexport const MODE_SSR = Symbol('MODE_SSR')\n\nexport class MockedEventEmitter {\n  emit() {}\n  emitAsync() {}\n  on() {}\n  once() {}\n  addListener() {}\n}\n\nexport const json = <T>(obj: T): T => {\n  return deepCopy(obj && obj[IS_PROXY] ? obj[VALUE] : obj)\n}\n  \n\nexport function isPromise(maybePromise: any) {\n  return (\n    maybePromise instanceof Promise ||\n    (maybePromise &&\n      typeof maybePromise.then === 'function' &&\n      typeof maybePromise.catch === 'function')\n  )\n}\n\nexport function processState(state: {}) {\n  return Object.keys(state).reduce((aggr, key) => {\n    if (key === '__esModule') {\n      return aggr\n    }\n    const originalDescriptor = Object.getOwnPropertyDescriptor(state, key)\n\n    if (originalDescriptor && 'get' in originalDescriptor) {\n      Object.defineProperty(aggr, key, originalDescriptor as any)\n\n      return aggr\n    }\n\n    const value = state[key]\n\n    if (isPlainObject(value)) {\n      aggr[key] = processState(value)\n    } else {\n      Object.defineProperty(aggr, key, originalDescriptor as any)\n    }\n\n    return aggr\n  }, {})\n}\n\nexport function getFunctionName(func: Function) {\n  return func.name || (func as any).displayName || ''\n}\n\nexport function deepCopy(obj) {\n  if (isPlainObject(obj)) {\n    return Object.keys(obj).reduce((aggr: any, key) => {\n      if (key === '__esModule') {\n        return aggr\n      }\n\n      const originalDescriptor = Object.getOwnPropertyDescriptor(obj, key)\n      const isAGetter = originalDescriptor && 'get' in originalDescriptor\n      const value = obj[key]\n\n      if (isAGetter) {\n        Object.defineProperty(aggr, key, originalDescriptor as any)\n      } else {\n        aggr[key] = deepCopy(value)\n      }\n\n      return aggr\n    }, {})\n  } else if (Array.isArray(obj)) {\n    return obj.map((item) => deepCopy(item))\n  }\n\n  return obj\n}\n\nexport function mergeState(originState, oldState, nextState) {\n  function merge(origin, old, next) {\n    if (isPlainObject(old) && isPlainObject(next)) {\n      const newBranch = {}\n      const keys = Object.keys(old).concat(Object.keys(next))\n\n      for (let key of keys) {\n        newBranch[key] = merge(origin[key], old[key], next[key])\n      }\n\n      return newBranch\n    }\n\n    if (typeof next === 'function') {\n      return next\n    }\n\n    // We return the existing array, as arrays are typically\n    // mutated, not set with new values as initial state\n    if (Array.isArray(old) && Array.isArray(next)) {\n      return old\n    }\n\n    // If we have changed a state from origin, keep that\n    // changed state\n    if (next === origin && old !== origin) {\n      return old\n    }\n\n    return next\n  }\n\n  return merge(originState, oldState, nextState)\n}\n\nexport function getActionPaths(actions = {}, currentPath: string[] = []) {\n  return Object.keys(actions).reduce<string[]>((aggr, key) => {\n    if (typeof actions[key] === 'function') {\n      return aggr.concat(currentPath.concat(key).join('.'))\n    }\n\n    return aggr.concat(getActionPaths(actions[key], currentPath.concat(key)))\n  }, [])\n}\n\nexport function createActionsProxy(actions, cb) {\n  return new Proxy(actions, {\n    get(target, prop) {\n      if (prop === ORIGINAL_ACTIONS) {\n        return actions\n      }\n\n      if (typeof target[prop] === 'function') {\n        return cb(target[prop])\n      }\n\n      if (!target[prop]) {\n        return undefined\n      }\n\n      return createActionsProxy(target[prop], cb)\n    },\n  })\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}