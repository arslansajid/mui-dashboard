{"ast":null,"code":"import { EventType } from './internalTypes';\nimport { IS_OPERATOR, MODE_TEST, ORIGINAL_ACTIONS, createActionsProxy } from './utils';\nexport function operatorStarted(type, arg, context) {\n  if (process.env.NODE_ENV === 'production') {\n    return;\n  }\n\n  const name = typeof arg === 'function' ? arg.displayName || arg.name : String(arg);\n  context.execution.isRunning = true;\n  context.execution.emit(EventType.OPERATOR_START, Object.assign(Object.assign({}, context.execution), {\n    name,\n    type\n  }));\n}\nexport function operatorStopped(context, value, details = {}) {\n  if (process.env.NODE_ENV === 'production') {\n    if (value instanceof Promise) {\n      context.execution.emit(EventType.OPERATOR_ASYNC, Object.assign(Object.assign({}, context.execution), {\n        isAsync: true\n      }));\n    }\n\n    return;\n  }\n\n  const evaluatedDetails = {\n    error: details.error ? details.error.message : undefined,\n    isIntercepted: Boolean(details.isIntercepted),\n    isSkipped: Boolean(details.isSkipped)\n  };\n\n  if (value instanceof Promise) {\n    value.then(promiseValue => {\n      context.execution.isRunning = false;\n      context.execution.emit(EventType.OPERATOR_END, Object.assign(Object.assign(Object.assign({}, context.execution), {\n        result: promiseValue,\n        isAsync: true\n      }), evaluatedDetails));\n    }).catch(() => {// Make sure an error does not cause uncaught\n    });\n  } else {\n    context.execution.isRunning = false;\n    context.execution.emit(EventType.OPERATOR_END, Object.assign(Object.assign(Object.assign({}, context.execution), {\n      result: value,\n      isAsync: false\n    }), evaluatedDetails));\n  }\n}\nexport function createContext(context, value, path) {\n  if (process.env.NODE_ENV === 'production') {\n    return Object.assign(Object.assign({}, context), {\n      value\n    });\n  }\n\n  const newExecution = Object.assign(Object.assign({}, context.execution), {\n    operatorId: context.execution.getNextOperatorId(),\n    path: path || context.execution.path\n  });\n  const mutationTrees = [];\n  return Object.assign(Object.assign({}, context), {\n    actions: createActionsProxy(context.actions[ORIGINAL_ACTIONS] || context.actions, action => {\n      return value => action(value, newExecution.isRunning ? newExecution : null);\n    }),\n    value,\n    execution: newExecution,\n    effects: context.execution.trackEffects(newExecution),\n    flush: context.parentExecution ? context.parentExecution.flush : isAsync => {\n      return this.proxyStateTree.flush(mutationTrees, isAsync);\n    },\n    getMutationTree: context.parentExecution ? context.parentExecution.getMutationTree : () => {\n      const mutationTree = this.proxyStateTree.getMutationTree();\n      mutationTrees.push(mutationTree);\n\n      if (this.mode.mode === MODE_TEST) {\n        mutationTree.onMutation(mutation => {\n          this.addExecutionMutation(mutation);\n        });\n      }\n\n      return mutationTree;\n    }\n  });\n}\nexport function createNextPath(next) {\n  if (process.env.NODE_ENV === 'production') {\n    return next;\n  }\n\n  return (err, context) => {\n    const newContext = Object.assign(Object.assign({}, context), {\n      execution: Object.assign(Object.assign({}, context.execution), {\n        path: context.execution.path.slice(0, context.execution.path.length - 1)\n      })\n    });\n    if (err) next(err, newContext);else next(null, newContext);\n  };\n}\nexport function createOperator(type, name, cb) {\n  const operator = (err, context, next, final) => {\n    operatorStarted(type, name, context);\n    let nextIsCalled = false;\n\n    try {\n      cb(err, {\n        state: context.state,\n        effects: context.effects,\n        actions: context.actions,\n        execution: context.execution,\n        revertable: context.revertable\n      }, context.value, (err, value, options = {}) => {\n        function run(err, value) {\n          if (options.path) {\n            const newContext = createContext(context, value, context.execution.path && context.execution.path.concat(options.path.name));\n            const nextWithPath = createNextPath(next);\n            options.path.operator(err, newContext, (...args) => {\n              operatorStopped(context, args[1].value);\n              nextWithPath(...args);\n            });\n          } else {\n            operatorStopped(context, err || value, {\n              isSkipped: err ? true : options.isSkipped\n            });\n            next(err, createContext(context, value));\n          }\n        }\n\n        if (value && value instanceof Promise) {\n          value.then(promiseValue => run(err, promiseValue)).catch(promiseError => run(promiseError, promiseError));\n        } else {\n          nextIsCalled = true;\n          run(err, value);\n        }\n      }, (err, value) => {\n        nextIsCalled = true;\n        operatorStopped(context, err || value, {\n          isSkipped: Boolean(err),\n          isIntercepted: !err\n        });\n        final(err, createContext(context, value));\n      });\n    } catch (error) {\n      nextIsCalled = true;\n      operatorStopped(context, context.value, {\n        error\n      });\n      next(error, createContext(context, context.value));\n    }\n\n    if (!nextIsCalled) {\n      context.execution.emit(EventType.OPERATOR_ASYNC, Object.assign(Object.assign({}, context.execution), {\n        isAsync: true\n      }));\n    }\n  };\n\n  operator[IS_OPERATOR] = true;\n  return operator;\n}\nexport function createMutationOperator(type, name, cb) {\n  const operator = (err, context, next, final) => {\n    operatorStarted(type, name, context);\n    const mutationTree = context.execution.getMutationTree();\n\n    if (!(process.env.NODE_ENV === 'production')) {\n      mutationTree.onMutation(mutation => {\n        context.execution.emit(EventType.MUTATIONS, Object.assign(Object.assign({}, context.execution), {\n          mutations: [mutation]\n        }));\n      });\n    }\n\n    let nextIsCalled = false;\n\n    try {\n      cb(err, {\n        state: mutationTree.state,\n        effects: context.effects,\n        actions: context.actions,\n        execution: context.execution,\n        revertable: context.revertable\n      }, process.env.NODE_ENV === 'production' ? context.value : context.execution.scopeValue(context.value, mutationTree), (err, value, options = {}) => {\n        function run(err, value) {\n          operatorStopped(context, err || value, {\n            isSkipped: err ? true : options.isSkipped\n          });\n          mutationTree.dispose();\n          next(err, createContext(context, value));\n        }\n\n        if (value && value instanceof Promise) {\n          value.then(promiseValue => run(err, promiseValue)).catch(promiseError => run(promiseError, promiseError));\n        } else {\n          nextIsCalled = true;\n          run(err, value);\n        }\n      }, (err, value) => {\n        nextIsCalled = true;\n        operatorStopped(context, err || value, {\n          isSkipped: Boolean(err),\n          isIntercepted: !err\n        });\n        final(err, createContext(context, value));\n      });\n\n      if (!(process.env.NODE_ENV === 'production')) {\n        let pendingFlush;\n        mutationTree.onMutation(() => {\n          if (pendingFlush) {\n            clearTimeout(pendingFlush);\n          }\n\n          pendingFlush = setTimeout(() => {\n            const flushData = context.execution.flush(true);\n\n            if (flushData.mutations.length) {\n              context.execution.send({\n                type: 'flush',\n                data: Object.assign(Object.assign(Object.assign({}, context.execution), flushData), {\n                  mutations: flushData.mutations\n                })\n              });\n            }\n          });\n        });\n      }\n    } catch (error) {\n      nextIsCalled = true;\n      operatorStopped(context, context.value, {\n        error\n      });\n      next(error, createContext(context, context.value));\n    }\n\n    if (!nextIsCalled) {\n      context.execution.emit(EventType.OPERATOR_ASYNC, Object.assign(Object.assign({}, context.execution), {\n        isAsync: true\n      }));\n    }\n  };\n\n  operator[IS_OPERATOR] = true;\n  return operator;\n}","map":{"version":3,"sources":["../src/operator.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventType, Execution } from './internalTypes'\nimport { IConfiguration, IContext, IOperator } from './types'\nimport {\n  IS_OPERATOR,\n  MODE_TEST,\n  ORIGINAL_ACTIONS,\n  createActionsProxy,\n} from './utils'\n\nexport function operatorStarted(type, arg, context) {\n  if (process.env.NODE_ENV === 'production') {\n    return\n  }\n  const name =\n    typeof arg === 'function' ? arg.displayName || arg.name : String(arg)\n\n  context.execution.isRunning = true\n  context.execution.emit(EventType.OPERATOR_START, {\n    ...context.execution,\n    name,\n    type,\n  })\n}\n\nexport function operatorStopped(\n  context,\n  value,\n  details: {\n    error?: Error\n    isIntercepted?: boolean\n    isSkipped?: boolean\n  } = {}\n) {\n  if (process.env.NODE_ENV === 'production') {\n    if (value instanceof Promise) {\n      context.execution.emit(EventType.OPERATOR_ASYNC, {\n        ...context.execution,\n        isAsync: true,\n      })\n    }\n    return\n  }\n\n  const evaluatedDetails = {\n    error: details.error ? details.error.message : undefined,\n    isIntercepted: Boolean(details.isIntercepted),\n    isSkipped: Boolean(details.isSkipped),\n  }\n\n  if (value instanceof Promise) {\n    value\n      .then((promiseValue) => {\n        context.execution.isRunning = false\n        context.execution.emit(EventType.OPERATOR_END, {\n          ...context.execution,\n          result: promiseValue,\n          isAsync: true,\n          ...evaluatedDetails,\n        })\n      })\n      .catch(() => {\n        // Make sure an error does not cause uncaught\n      })\n  } else {\n    context.execution.isRunning = false\n    context.execution.emit(EventType.OPERATOR_END, {\n      ...context.execution,\n      result: value,\n      isAsync: false,\n      ...evaluatedDetails,\n    })\n  }\n}\n\nexport function createContext(context, value, path?) {\n  if (process.env.NODE_ENV === 'production') {\n    return {\n      ...context,\n      value,\n    }\n  }\n\n  const newExecution = {\n    ...context.execution,\n    operatorId: context.execution.getNextOperatorId(),\n    path: path || context.execution.path,\n  }\n\n  const mutationTrees: any[] = []\n  return {\n    ...context,\n    actions: createActionsProxy(\n      context.actions[ORIGINAL_ACTIONS] || context.actions,\n      (action) => {\n        return (value) =>\n          action(value, newExecution.isRunning ? newExecution : null)\n      }\n    ),\n    value,\n    execution: newExecution,\n    effects: context.execution.trackEffects(newExecution),\n    flush: context.parentExecution\n      ? context.parentExecution.flush\n      : (isAsync?: boolean) => {\n          return this.proxyStateTree.flush(mutationTrees, isAsync)\n        },\n    getMutationTree: context.parentExecution\n      ? context.parentExecution.getMutationTree\n      : () => {\n          const mutationTree = this.proxyStateTree.getMutationTree()\n\n          mutationTrees.push(mutationTree)\n\n          if (this.mode.mode === MODE_TEST) {\n            mutationTree.onMutation((mutation) => {\n              this.addExecutionMutation(mutation)\n            })\n          }\n          return mutationTree\n        },\n  }\n}\n\nexport function createNextPath(next) {\n  if (process.env.NODE_ENV === 'production') {\n    return next\n  }\n\n  return (err, context) => {\n    const newContext = {\n      ...context,\n      execution: {\n        ...context.execution,\n        path: context.execution.path.slice(\n          0,\n          context.execution.path.length - 1\n        ),\n      },\n    }\n    if (err) next(err, newContext)\n    else next(null, newContext)\n  }\n}\n\nexport function createOperator<ThisConfig extends IConfiguration>(\n  type: string,\n  name: string,\n  cb: (\n    err: Error | null,\n    context: IContext<ThisConfig> & { execution: Execution },\n    value: any,\n    next: (\n      err: Error | null,\n      value: any,\n      options?: {\n        path?: { name: string; operator: Function }\n        isSkipped?: boolean\n      }\n    ) => void,\n    final: (err: Error | null, value: any) => void\n  ) => any\n): any {\n  const operator = (err, context, next, final) => {\n    operatorStarted(type, name, context)\n    let nextIsCalled = false\n    try {\n      cb(\n        err,\n        {\n          state: context.state,\n          effects: context.effects,\n          actions: context.actions,\n          execution: context.execution,\n          revertable: context.revertable,\n        },\n        context.value,\n        (err, value, options = {}) => {\n          function run(err, value) {\n            if (options.path) {\n              const newContext = createContext(\n                context,\n                value,\n                context.execution.path &&\n                  context.execution.path.concat(options.path.name)\n              )\n              const nextWithPath = createNextPath(next)\n              options.path.operator(err, newContext, (...args) => {\n                operatorStopped(context, args[1].value)\n                nextWithPath(...args)\n              })\n            } else {\n              operatorStopped(context, err || value, {\n                isSkipped: err ? true : options.isSkipped,\n              })\n              next(err, createContext(context, value))\n            }\n          }\n\n          if (value && value instanceof Promise) {\n            value\n              .then((promiseValue) => run(err, promiseValue))\n              .catch((promiseError) => run(promiseError, promiseError))\n          } else {\n            nextIsCalled = true\n            run(err, value)\n          }\n        },\n        (err, value) => {\n          nextIsCalled = true\n          operatorStopped(context, err || value, {\n            isSkipped: Boolean(err),\n            isIntercepted: !err,\n          })\n          final(err, createContext(context, value))\n        }\n      )\n    } catch (error) {\n      nextIsCalled = true\n      operatorStopped(context, context.value, {\n        error,\n      })\n      next(error, createContext(context, context.value))\n    }\n\n    if (!nextIsCalled) {\n      context.execution.emit(EventType.OPERATOR_ASYNC, {\n        ...context.execution,\n        isAsync: true,\n      })\n    }\n  }\n\n  operator[IS_OPERATOR] = true\n\n  return operator\n}\n\nexport function createMutationOperator<ThisConfig extends IConfiguration>(\n  type: string,\n  name: string,\n  cb: (\n    err: Error | null,\n    context: IContext<ThisConfig> & { execution: Execution },\n    value: any,\n    next: (\n      err: Error | null,\n      value: any,\n      options?: {\n        path?: { name: string; operator: Function }\n        isSkipped?: boolean\n      }\n    ) => void,\n    final: (err: Error | null, value: any) => void\n  ) => any\n): any {\n  const operator = (err, context, next, final) => {\n    operatorStarted(type, name, context)\n    const mutationTree = context.execution.getMutationTree()\n    if (!(process.env.NODE_ENV === 'production')) {\n      mutationTree.onMutation((mutation) => {\n        context.execution.emit(EventType.MUTATIONS, {\n          ...context.execution,\n          mutations: [mutation],\n        })\n      })\n    }\n    let nextIsCalled = false\n    try {\n      cb(\n        err,\n        {\n          state: mutationTree.state,\n          effects: context.effects,\n          actions: context.actions,\n          execution: context.execution,\n          revertable: context.revertable,\n        },\n        process.env.NODE_ENV === 'production'\n          ? context.value\n          : context.execution.scopeValue(context.value, mutationTree),\n        (err, value, options = {}) => {\n          function run(err, value) {\n            operatorStopped(context, err || value, {\n              isSkipped: err ? true : options.isSkipped,\n            })\n            mutationTree.dispose()\n            next(err, createContext(context, value))\n          }\n\n          if (value && value instanceof Promise) {\n            value\n              .then((promiseValue) => run(err, promiseValue))\n              .catch((promiseError) => run(promiseError, promiseError))\n          } else {\n            nextIsCalled = true\n            run(err, value)\n          }\n        },\n        (err, value) => {\n          nextIsCalled = true\n          operatorStopped(context, err || value, {\n            isSkipped: Boolean(err),\n            isIntercepted: !err,\n          })\n          final(err, createContext(context, value))\n        }\n      )\n\n      if (!(process.env.NODE_ENV === 'production')) {\n        let pendingFlush\n        mutationTree.onMutation(() => {\n          if (pendingFlush) {\n            clearTimeout(pendingFlush)\n          }\n          pendingFlush = setTimeout(() => {\n            const flushData = context.execution.flush(true)\n\n            if (flushData.mutations.length) {\n              context.execution.send({\n                type: 'flush',\n                data: {\n                  ...context.execution,\n                  ...flushData,\n                  mutations: flushData.mutations,\n                },\n              })\n            }\n          })\n        })\n      }\n    } catch (error) {\n      nextIsCalled = true\n      operatorStopped(context, context.value, {\n        error,\n      })\n      next(error, createContext(context, context.value))\n    }\n\n    if (!nextIsCalled) {\n      context.execution.emit(EventType.OPERATOR_ASYNC, {\n        ...context.execution,\n        isAsync: true,\n      })\n    }\n  }\n\n  operator[IS_OPERATOR] = true\n\n  return operator\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}