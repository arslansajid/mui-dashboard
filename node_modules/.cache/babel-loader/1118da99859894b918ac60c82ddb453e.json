{"ast":null,"code":"import { Proxifier } from './Proxyfier';\nexport class MutationTree {\n  constructor(master, proxifier) {\n    this.mutationCallbacks = [];\n    this.mutations = [];\n    this.objectChanges = new Set();\n    this.isTracking = false;\n    this.isBlocking = false;\n    this.trackPathListeners = [];\n    this.isTracking = true;\n    this.master = master;\n    this.proxifier = proxifier || new Proxifier(this);\n    this.state = this.proxifier.proxify(master.sourceState, '');\n  }\n\n  trackPaths() {\n    const paths = new Set();\n\n    const listener = path => {\n      paths.add(path);\n    };\n\n    this.trackPathListeners.push(listener);\n    return () => {\n      this.trackPathListeners.splice(this.trackPathListeners.indexOf(listener), 1);\n      return paths;\n    };\n  }\n\n  getMutations() {\n    const mutations = this.mutations.slice();\n    this.mutations.length = 0;\n    return mutations;\n  }\n\n  getObjectChanges() {\n    const objectChanges = new Set([...this.objectChanges]);\n    this.objectChanges.clear();\n    return objectChanges;\n  }\n\n  addMutation(mutation, objectChangePath) {\n    const currentFlushId = this.master.currentFlushId;\n    this.mutations.push(mutation);\n\n    if (objectChangePath) {\n      this.objectChanges.add(objectChangePath);\n    }\n\n    for (let cb of this.master.mutationCallbacks) {\n      cb(mutation, new Set(objectChangePath ? [mutation.path, objectChangePath] : [mutation.path]), currentFlushId);\n    }\n\n    for (let callback of this.mutationCallbacks) {\n      callback(mutation, new Set(objectChangePath ? [mutation.path, objectChangePath] : [mutation.path]), currentFlushId);\n    }\n  }\n\n  flush(isAsync = false) {\n    return this.master.flush(this, isAsync);\n  }\n\n  onMutation(callback) {\n    this.mutationCallbacks.push(callback);\n  }\n\n  canMutate() {\n    return this.isTracking && !this.isBlocking;\n  }\n\n  canTrack() {\n    return false;\n  }\n\n  blockMutations() {\n    this.isBlocking = true;\n  }\n\n  enableMutations() {\n    this.isBlocking = false;\n  }\n\n  dispose() {\n    this.isTracking = false;\n    this.mutationCallbacks.length = 0;\n    this.proxifier = this.master.proxifier;\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../src/MutationTree.ts"],"names":[],"mappings":"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","sourcesContent":["import { Proxifier } from './Proxyfier'\nimport {\n  IMutation,\n  IMutationCallback,\n  IMutationTree,\n  IProxifier,\n  IProxyStateTree,\n} from './types'\n\nexport class MutationTree<T extends object> implements IMutationTree<T> {\n  private mutationCallbacks: IMutationCallback[] = []\n  master: IProxyStateTree<T>\n  state: T\n  proxifier: IProxifier<T>\n  mutations: IMutation[] = []\n  objectChanges = new Set<string>()\n  isTracking: boolean = false\n  isBlocking: boolean = false\n  trackPathListeners: Array<(path: string) => void> = []\n  constructor(master: IProxyStateTree<T>, proxifier?: IProxifier<T>) {\n    this.isTracking = true\n    this.master = master\n    this.proxifier = proxifier || new Proxifier(this)\n    this.state = this.proxifier.proxify(master.sourceState, '')\n  }\n  trackPaths() {\n    const paths = new Set<string>()\n    const listener = (path) => {\n      paths.add(path)\n    }\n    this.trackPathListeners.push(listener)\n\n    return () => {\n      this.trackPathListeners.splice(\n        this.trackPathListeners.indexOf(listener),\n        1\n      )\n\n      return paths\n    }\n  }\n  getMutations() {\n    const mutations = this.mutations.slice()\n\n    this.mutations.length = 0\n\n    return mutations\n  }\n  getObjectChanges() {\n    const objectChanges = new Set([...this.objectChanges])\n\n    this.objectChanges.clear()\n\n    return objectChanges\n  }\n  addMutation(mutation: IMutation, objectChangePath?: string) {\n    const currentFlushId = this.master.currentFlushId\n\n    this.mutations.push(mutation)\n\n    if (objectChangePath) {\n      this.objectChanges.add(objectChangePath)\n    }\n\n    for (let cb of this.master.mutationCallbacks) {\n      cb(\n        mutation,\n        new Set(\n          objectChangePath ? [mutation.path, objectChangePath] : [mutation.path]\n        ),\n        currentFlushId\n      )\n    }\n\n    for (let callback of this.mutationCallbacks) {\n      callback(\n        mutation,\n        new Set(\n          objectChangePath ? [mutation.path, objectChangePath] : [mutation.path]\n        ),\n        currentFlushId\n      )\n    }\n  }\n  flush(isAsync: boolean = false) {\n    return this.master.flush(this, isAsync)\n  }\n  onMutation(callback: IMutationCallback) {\n    this.mutationCallbacks.push(callback)\n  }\n  canMutate() {\n    return this.isTracking && !this.isBlocking\n  }\n  canTrack() {\n    return false\n  }\n  blockMutations() {\n    this.isBlocking = true\n  }\n  enableMutations() {\n    this.isBlocking = false\n  }\n  dispose() {\n    this.isTracking = false\n    this.mutationCallbacks.length = 0\n    this.proxifier = this.master.proxifier\n\n    return this\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}