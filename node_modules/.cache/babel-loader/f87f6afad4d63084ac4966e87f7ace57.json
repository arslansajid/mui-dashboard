{"ast":null,"code":"import isPlainObject from 'is-plain-obj';\nexport const IS_PROXY = Symbol('IS_PROXY');\nexport const PATH = Symbol('PATH');\nexport const VALUE = Symbol('VALUE');\nexport const PROXY_TREE = Symbol('PROXY_TREE');\nconst arrayMutations = new Set(['push', 'shift', 'pop', 'unshift', 'splice', 'reverse', 'sort', 'copyWithin']);\n\nconst getValue = proxyOrValue => proxyOrValue && proxyOrValue[IS_PROXY] ? proxyOrValue[VALUE] : proxyOrValue;\n\nconst isClass = value => typeof value === 'object' && value !== null && !Array.isArray(value) && value.constructor.name !== 'Object' && Object.isExtensible(value);\n\nconst getArrayMutationRevert = (method, target, args) => {\n  switch (method) {\n    case 'push':\n      {\n        return () => {\n          target.splice(target.indexOf(args[0]), 1);\n        };\n      }\n\n    case 'shift':\n      {\n        const value = target[0];\n        return () => {\n          target.unshift(value);\n        };\n      }\n\n    case 'pop':\n      {\n        const index = target.length - 1;\n        const value = target[index];\n        return () => {\n          target.splice(index, 1, value);\n        };\n      }\n\n    case 'unshift':\n      {\n        return () => {\n          target.splice(target.indexOf(args[0]), 1);\n        };\n      }\n\n    case 'splice':\n      {\n        const removedValues = target.slice(args[0], args[1]);\n        const addedValues = args.slice(2);\n        return () => target.splice(args[0], args[1] + addedValues.length, ...removedValues);\n      }\n\n    case 'reverse':\n      {\n        return () => target.reverse();\n      }\n\n    case 'sort':\n      {\n        return () => target.sort((a, b) => -1 * args[0](a, b));\n      }\n\n    case 'copyWithin':\n      {\n        return () => target;\n      }\n  }\n};\n\nexport class Proxifier {\n  constructor(tree) {\n    this.tree = tree;\n    this.CACHED_PROXY = Symbol('CACHED_PROXY');\n    this.delimiter = tree.master.options.delimiter;\n  }\n\n  concat(path, prop) {\n    return path ? path + this.delimiter + prop : prop;\n  }\n\n  ensureMutationTrackingIsEnabled(path) {\n    if (process.env.NODE_ENV === 'production') return;\n\n    if (this.tree.master.options.devmode && !this.tree.canMutate()) {\n      throw new Error(`proxy-state-tree - You are mutating the path \"${path}\", but it is not allowed. The following could have happened:\n        \n        - The mutation is explicitly being blocket\n        - You are passing state to a 3rd party tool trying to manipulate the state\n        - You are running asynchronous code and forgot to \"await\" its execution\n        `);\n    }\n  }\n\n  isDefaultProxifier() {\n    return this.tree.proxifier === this.tree.master.proxifier;\n  }\n\n  ensureValueDosntExistInStateTreeElsewhere(value) {\n    if (process.env.NODE_ENV === 'production') return;\n\n    if (value && value[IS_PROXY] === true) {\n      throw new Error(`proxy-state-tree - You are trying to insert a value that already exists in the state tree on path \"${value[PATH]}\"`);\n    }\n\n    return value;\n  }\n\n  trackPath(path) {\n    if (!this.tree.canTrack()) {\n      return;\n    }\n\n    if (this.isDefaultProxifier()) {\n      const trackStateTree = this.tree.master.currentTree;\n\n      if (!trackStateTree) {\n        return;\n      }\n\n      trackStateTree.addTrackingPath(path);\n    } else {\n      ;\n      this.tree.addTrackingPath(path);\n    }\n  } // With tracking trees we want to ensure that we are always\n  // on the currently tracked tree. This ensures when we access\n  // a tracking proxy that is not part of the current tracking tree (pass as prop)\n  // we move the ownership to the current tracker\n\n\n  getTrackingTree() {\n    if (this.tree.master.currentTree && this.isDefaultProxifier()) {\n      return this.tree.master.currentTree;\n    }\n\n    if (!this.tree.canTrack()) {\n      return null;\n    }\n\n    if (this.tree.canTrack()) {\n      return this.tree;\n    }\n\n    return null;\n  }\n\n  getMutationTree() {\n    return this.tree.master.mutationTree || this.tree;\n  }\n\n  isProxyCached(value, path) {\n    return value[this.CACHED_PROXY] && String(value[this.CACHED_PROXY][PATH]) === String(path);\n  }\n\n  createArrayProxy(value, path) {\n    if (this.isProxyCached(value, path)) {\n      return value[this.CACHED_PROXY];\n    }\n\n    const proxifier = this;\n    const proxy = new Proxy(value, {\n      get(target, prop) {\n        if (prop === IS_PROXY) return true;\n        if (prop === PATH) return path;\n        if (prop === VALUE) return value;\n\n        if (prop === 'indexOf') {\n          return (searchTerm, offset) => value.indexOf(getValue(searchTerm), getValue(offset));\n        }\n\n        if (prop === 'length' || typeof target[prop] === 'function' && !arrayMutations.has(String(prop)) || typeof prop === 'symbol' || target[prop] instanceof Date) {\n          return target[prop];\n        }\n\n        const trackingTree = proxifier.getTrackingTree();\n        const nestedPath = proxifier.concat(path, prop);\n        const currentTree = trackingTree || proxifier.tree;\n        trackingTree && trackingTree.proxifier.trackPath(nestedPath);\n        currentTree.trackPathListeners.forEach(cb => cb(nestedPath));\n        const method = String(prop);\n\n        if (arrayMutations.has(method)) {\n          /* @__PURE__ */\n          proxifier.ensureMutationTrackingIsEnabled(nestedPath);\n          return (...args) => {\n            const mutationTree = proxifier.getMutationTree();\n            let result;\n\n            if (process.env.NODE_ENV === 'production') {\n              result = target[prop](...args);\n            } else {\n              result = target[prop](...args.map(arg => /* @__PURE__ */proxifier.ensureValueDosntExistInStateTreeElsewhere(arg)));\n            }\n\n            mutationTree.addMutation({\n              method,\n              path: path,\n              delimiter: proxifier.delimiter,\n              args: args,\n              hasChangedValue: true,\n              revert: getArrayMutationRevert(method, proxy, args)\n            });\n            return result;\n          };\n        }\n\n        if (target[prop] === undefined) {\n          return undefined;\n        }\n\n        return proxifier.proxify(target[prop], nestedPath);\n      },\n\n      set(target, prop, value) {\n        const nestedPath = proxifier.concat(path, prop);\n        /* @__PURE__ */\n\n        proxifier.ensureMutationTrackingIsEnabled(nestedPath);\n        /* @__PURE__ */\n\n        proxifier.ensureValueDosntExistInStateTreeElsewhere(value);\n        const mutationTree = proxifier.getMutationTree();\n        const existingValue = target[prop];\n        const result = Reflect.set(target, prop, value);\n        mutationTree.addMutation({\n          method: 'set',\n          path: nestedPath,\n          args: [value],\n          delimiter: proxifier.delimiter,\n          hasChangedValue: true,\n          revert: () => {\n            if (existingValue === undefined) {\n              delete proxy[prop];\n            } else {\n              proxy[prop] = existingValue;\n            }\n          }\n        });\n        return result;\n      }\n\n    });\n    Object.defineProperty(value, this.CACHED_PROXY, {\n      value: proxy,\n      configurable: true\n    });\n    return proxy;\n  }\n\n  createObjectProxy(object, path) {\n    if (this.isProxyCached(object, path)) {\n      return object[this.CACHED_PROXY];\n    }\n\n    const proxifier = this;\n    const proxy = new Proxy(object, {\n      get(target, prop) {\n        if (prop === IS_PROXY) return true;\n        if (prop === PATH) return path;\n        if (prop === VALUE) return object;\n        if (prop === PROXY_TREE) return proxifier.tree;\n        if (typeof prop === 'symbol' || prop in Object.prototype || target[prop] instanceof Date) return target[prop];\n        const descriptor = Object.getOwnPropertyDescriptor(target, prop) || Object.getOwnPropertyDescriptor(Object.getPrototypeOf(target), prop);\n\n        if (descriptor && 'get' in descriptor) {\n          const value = descriptor.get.call(proxy);\n\n          if (proxifier.tree.master.options.devmode && proxifier.tree.master.options.onGetter) {\n            proxifier.tree.master.options.onGetter(proxifier.concat(path, prop), value);\n          }\n\n          return value;\n        }\n\n        const trackingTree = proxifier.getTrackingTree();\n        const targetValue = target[prop];\n        const nestedPath = proxifier.concat(path, prop);\n        const currentTree = trackingTree || proxifier.tree;\n\n        if (typeof targetValue === 'function' && isClass(target)) {\n          return (...args) => targetValue.call(proxy, ...args);\n        } else if (typeof targetValue === 'function') {\n          if (proxifier.tree.master.options.onFunction) {\n            const {\n              func,\n              value\n            } = proxifier.tree.master.options.onFunction(trackingTree || proxifier.tree, nestedPath, targetValue);\n            target[prop] = func;\n            return value;\n          }\n\n          return targetValue.call(target, proxifier.tree, nestedPath);\n        } else {\n          currentTree.trackPathListeners.forEach(cb => cb(nestedPath));\n          trackingTree && trackingTree.proxifier.trackPath(nestedPath);\n        }\n\n        if (targetValue === undefined) {\n          return undefined;\n        }\n\n        return proxifier.proxify(targetValue, nestedPath);\n      },\n\n      set(target, prop, value) {\n        const nestedPath = proxifier.concat(path, prop);\n        /* @__PURE__ */\n\n        proxifier.ensureMutationTrackingIsEnabled(nestedPath);\n        /* @__PURE__ */\n\n        proxifier.ensureValueDosntExistInStateTreeElsewhere(value);\n        let objectChangePath;\n\n        if (!(prop in target)) {\n          objectChangePath = path;\n        }\n\n        const mutationTree = proxifier.getMutationTree();\n        const existingValue = target[prop];\n\n        if (typeof value === 'function' && proxifier.tree.master.options.onFunction) {\n          const result = proxifier.tree.master.options.onFunction(proxifier.getTrackingTree() || proxifier.tree, nestedPath, value);\n          value = result.func;\n        }\n\n        const hasChangedValue = value !== target[prop];\n        const result = Reflect.set(target, prop, value);\n        mutationTree.addMutation({\n          method: 'set',\n          path: nestedPath,\n          args: [value],\n          delimiter: proxifier.delimiter,\n          hasChangedValue,\n          revert: () => {\n            if (existingValue === undefined) {\n              delete proxy[prop];\n            } else {\n              proxy[prop] = existingValue;\n            }\n          }\n        }, objectChangePath);\n        return result;\n      },\n\n      deleteProperty(target, prop) {\n        const nestedPath = proxifier.concat(path, prop);\n        /* @__PURE__ */\n\n        proxifier.ensureMutationTrackingIsEnabled(nestedPath);\n        let objectChangePath;\n\n        if (prop in target) {\n          objectChangePath = path;\n        }\n\n        const mutationTree = proxifier.getMutationTree();\n        const existingValue = target[prop];\n        delete target[prop];\n        mutationTree.addMutation({\n          method: 'unset',\n          path: nestedPath,\n          args: [],\n          delimiter: proxifier.delimiter,\n          hasChangedValue: true,\n          revert: () => {\n            proxy[prop] = existingValue;\n          }\n        }, objectChangePath);\n        return true;\n      }\n\n    });\n    Object.defineProperty(object, this.CACHED_PROXY, {\n      value: proxy,\n      configurable: true\n    });\n    return proxy;\n  }\n\n  proxify(value, path) {\n    if (value) {\n      const isUnmatchingProxy = value[IS_PROXY] && (String(value[PATH]) !== String(path) || value[VALUE][this.CACHED_PROXY] !== value);\n\n      if (isUnmatchingProxy) {\n        return this.proxify(value[VALUE], path);\n      } else if (value[IS_PROXY]) {\n        return value;\n      } else if (Array.isArray(value)) {\n        return this.createArrayProxy(value, path);\n      } else if (isPlainObject(value) || isClass(value)) {\n        return this.createObjectProxy(value, path);\n      }\n    }\n\n    return value;\n  }\n\n}","map":{"version":3,"sources":["../src/Proxyfier.ts"],"names":[],"mappings":"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","sourcesContent":["import isPlainObject from 'is-plain-obj'\n\nimport { IMutationTree, ITrackStateTree, TTree } from './types'\n\nexport const IS_PROXY = Symbol('IS_PROXY')\nexport const PATH = Symbol('PATH')\nexport const VALUE = Symbol('VALUE')\nexport const PROXY_TREE = Symbol('PROXY_TREE')\n\nconst arrayMutations = new Set([\n  'push',\n  'shift',\n  'pop',\n  'unshift',\n  'splice',\n  'reverse',\n  'sort',\n  'copyWithin',\n])\n\nconst getValue = (proxyOrValue) =>\n  proxyOrValue && proxyOrValue[IS_PROXY] ? proxyOrValue[VALUE] : proxyOrValue\n\nconst isClass = (value) => typeof value === 'object' && value !== null && !Array.isArray(value) && value.constructor.name !== 'Object' && Object.isExtensible(value)\n\nconst getArrayMutationRevert = (method: string, target: any[], args: any[]) => {\n  switch (method) {\n    case 'push': {\n      return () => {\n        target.splice(target.indexOf(args[0]), 1)\n      }\n    }\n    case 'shift': {\n      const value = target[0]\n      return () => {\n        target.unshift(value)\n      }\n    }\n    case 'pop': {\n      const index = target.length - 1\n      const value = target[index]\n\n      return () => {\n        target.splice(index, 1, value)\n      }\n    }\n    case 'unshift': {\n      return () => {\n        target.splice(target.indexOf(args[0]), 1)\n      }\n    }\n    case 'splice': {\n      const removedValues = target.slice(args[0], args[1])\n      const addedValues = args.slice(2)\n      return () =>\n        target.splice(args[0], args[1] + addedValues.length, ...removedValues)\n    }\n    case 'reverse': {\n      return () => target.reverse()\n    }\n    case 'sort': {\n      return () => target.sort((a, b) => -1 * args[0](a, b))\n    }\n    case 'copyWithin': {\n      return () => target\n    }\n  }\n}\n\nexport class Proxifier {\n  CACHED_PROXY = Symbol('CACHED_PROXY')\n  delimiter: string\n  constructor(private tree: TTree) {\n    this.delimiter = tree.master.options.delimiter\n  }\n  private concat(path, prop) {\n    return path ? path + this.delimiter + prop : prop\n  }\n\n  ensureMutationTrackingIsEnabled(path) {\n    if (process.env.NODE_ENV === 'production') return\n\n    if (this.tree.master.options.devmode && !this.tree.canMutate()) {\n      throw new Error(\n        `proxy-state-tree - You are mutating the path \"${path}\", but it is not allowed. The following could have happened:\n        \n        - The mutation is explicitly being blocket\n        - You are passing state to a 3rd party tool trying to manipulate the state\n        - You are running asynchronous code and forgot to \"await\" its execution\n        `\n      )\n    }\n  }\n\n  isDefaultProxifier() {\n    return this.tree.proxifier === this.tree.master.proxifier\n  }\n\n  ensureValueDosntExistInStateTreeElsewhere(value) {\n    if (process.env.NODE_ENV === 'production') return\n\n    if (value && value[IS_PROXY] === true) {\n      throw new Error(\n        `proxy-state-tree - You are trying to insert a value that already exists in the state tree on path \"${\n          value[PATH]\n        }\"`\n      )\n    }\n\n    return value\n  }\n\n  trackPath(path: string) {\n    if (!this.tree.canTrack()) {\n      return\n    }\n\n    if (this.isDefaultProxifier()) {\n      const trackStateTree = this.tree.master.currentTree as ITrackStateTree<\n        any\n      >\n\n      if (!trackStateTree) {\n        return\n      }\n\n      trackStateTree.addTrackingPath(path)\n    } else {\n      ;(this.tree as ITrackStateTree<any>).addTrackingPath(path)\n    }\n  }\n  // With tracking trees we want to ensure that we are always\n  // on the currently tracked tree. This ensures when we access\n  // a tracking proxy that is not part of the current tracking tree (pass as prop)\n  // we move the ownership to the current tracker\n  getTrackingTree() {\n    if (this.tree.master.currentTree && this.isDefaultProxifier()) {\n      return this.tree.master.currentTree\n    }\n\n    if (!this.tree.canTrack()) {\n      return null\n    }\n\n    if (this.tree.canTrack()) {\n      return this.tree\n    }\n\n    return null\n  }\n  getMutationTree() {\n    return this.tree.master.mutationTree || (this.tree as IMutationTree<any>)\n  }\n  private isProxyCached(value, path) {\n    return (\n      value[this.CACHED_PROXY] &&\n      String(value[this.CACHED_PROXY][PATH]) === String(path)\n    )\n  }\n  private createArrayProxy(value, path) {\n    if (this.isProxyCached(value, path)) {\n      return value[this.CACHED_PROXY]\n    }\n\n    const proxifier = this\n\n    const proxy = new Proxy(value, {\n      get(target, prop) {\n        if (prop === IS_PROXY) return true\n        if (prop === PATH) return path\n        if (prop === VALUE) return value\n        if (prop === 'indexOf') {\n          return (searchTerm, offset) =>\n            value.indexOf(getValue(searchTerm), getValue(offset))\n        }\n        if (\n          prop === 'length' ||\n          (typeof target[prop] === 'function' &&\n            !arrayMutations.has(String(prop))) ||\n          typeof prop === 'symbol' || target[prop] instanceof Date\n        ) {\n          return target[prop]\n        }\n\n        const trackingTree = proxifier.getTrackingTree()\n        const nestedPath = proxifier.concat(path, prop)\n        const currentTree = trackingTree || proxifier.tree\n\n        trackingTree && trackingTree.proxifier.trackPath(nestedPath)\n        currentTree.trackPathListeners.forEach((cb) => cb(nestedPath))\n\n        const method = String(prop)\n\n        if (arrayMutations.has(method)) {\n          /* @__PURE__ */ proxifier.ensureMutationTrackingIsEnabled(nestedPath)\n          return (...args) => {\n            const mutationTree = proxifier.getMutationTree()\n\n            let result\n\n\n            if (process.env.NODE_ENV === 'production') {\n              result =  target[prop](...args)\n            } else {\n              result = target[prop](\n                ...args.map((arg) =>\n                  /* @__PURE__ */ proxifier.ensureValueDosntExistInStateTreeElsewhere(\n                    arg\n                  )\n                )\n              )\n            }\n\n            mutationTree.addMutation({\n              method,\n              path: path,\n              delimiter: proxifier.delimiter,\n              args: args,\n              hasChangedValue: true,\n              revert: getArrayMutationRevert(method, proxy, args),\n            })\n\n            return result\n          }\n        }\n\n        if (target[prop] === undefined) {\n          return undefined\n        }\n\n        return proxifier.proxify(target[prop], nestedPath)\n      },\n      set(target, prop, value) {\n        const nestedPath = proxifier.concat(path, prop)\n\n        /* @__PURE__ */ proxifier.ensureMutationTrackingIsEnabled(nestedPath)\n        /* @__PURE__ */ proxifier.ensureValueDosntExistInStateTreeElsewhere(\n          value\n        )\n\n        const mutationTree = proxifier.getMutationTree()\n        const existingValue = target[prop]\n        const result = Reflect.set(target, prop, value)\n\n        mutationTree.addMutation({\n          method: 'set',\n          path: nestedPath,\n          args: [value],\n          delimiter: proxifier.delimiter,\n          hasChangedValue: true,\n          revert: () => {\n            if (existingValue === undefined) {\n              delete proxy[prop]\n            } else {\n              proxy[prop] = existingValue\n            }\n          },\n        })\n\n        return result\n      },\n    })\n\n    Object.defineProperty(value, this.CACHED_PROXY, {\n      value: proxy,\n      configurable: true,\n    })\n\n    return proxy\n  }\n\n  private createObjectProxy(object, path) {\n    if (this.isProxyCached(object, path)) {\n      return object[this.CACHED_PROXY]\n    }\n\n    const proxifier = this\n\n    const proxy = new Proxy(object, {\n      get(target, prop) {\n        if (prop === IS_PROXY) return true\n        if (prop === PATH) return path\n        if (prop === VALUE) return object\n        if (prop === PROXY_TREE) return proxifier.tree\n\n        if (typeof prop === 'symbol' || prop in Object.prototype || target[prop] instanceof Date)\n          return target[prop]\n\n        const descriptor = Object.getOwnPropertyDescriptor(target, prop) || Object.getOwnPropertyDescriptor(Object.getPrototypeOf(target), prop)\n\n        if (descriptor && 'get' in descriptor) {\n          const value = descriptor.get.call(proxy)\n\n          if (\n            proxifier.tree.master.options.devmode &&\n            proxifier.tree.master.options.onGetter\n          ) {\n            proxifier.tree.master.options.onGetter(\n              proxifier.concat(path, prop),\n              value\n            )\n          }\n\n          return value\n        }\n\n        const trackingTree = proxifier.getTrackingTree()\n        const targetValue = target[prop]\n        const nestedPath = proxifier.concat(path, prop)\n        const currentTree = trackingTree || proxifier.tree\n\n        if (typeof targetValue === 'function' && isClass(target)) {\n          return (...args) => targetValue.call(proxy, ...args)\n        } else if (typeof targetValue === 'function') {\n          if (proxifier.tree.master.options.onFunction) {\n            const { func, value } = proxifier.tree.master.options.onFunction(\n              trackingTree || proxifier.tree,\n              nestedPath,\n              targetValue\n            )\n            \n            target[prop] = func\n\n            return value\n          }\n          return targetValue.call(target, proxifier.tree, nestedPath)\n        } else {\n          currentTree.trackPathListeners.forEach((cb) => cb(nestedPath))\n          trackingTree && trackingTree.proxifier.trackPath(nestedPath)\n        }\n\n        if (targetValue === undefined) {\n          return undefined\n        }\n\n        return proxifier.proxify(targetValue, nestedPath)\n      },\n      set(target, prop, value) {\n        const nestedPath = proxifier.concat(path, prop)\n\n        /* @__PURE__ */ proxifier.ensureMutationTrackingIsEnabled(nestedPath)\n        /* @__PURE__ */ proxifier.ensureValueDosntExistInStateTreeElsewhere(\n          value\n        )\n\n        let objectChangePath\n\n        if (!(prop in target)) {\n          objectChangePath = path\n        }\n\n        const mutationTree = proxifier.getMutationTree()\n        const existingValue = target[prop]\n\n        if (typeof value === 'function' && proxifier.tree.master.options.onFunction) {\n          const result = proxifier.tree.master.options.onFunction(\n            proxifier.getTrackingTree() || proxifier.tree,\n            nestedPath,\n            value\n          )\n          \n          value = result.func\n        }\n\n        const hasChangedValue = value !== target[prop]\n        const result = Reflect.set(target, prop, value)\n\n        mutationTree.addMutation(\n          {\n            method: 'set',\n            path: nestedPath,\n            args: [value],\n            delimiter: proxifier.delimiter,\n            hasChangedValue,\n            revert: () => {\n              if (existingValue === undefined) {\n                delete proxy[prop]\n              } else {\n                proxy[prop] = existingValue\n              }\n            },\n          },\n          objectChangePath\n        )\n\n        return result\n      },\n      deleteProperty(target, prop) {\n        const nestedPath = proxifier.concat(path, prop)\n\n        /* @__PURE__ */ proxifier.ensureMutationTrackingIsEnabled(nestedPath)\n\n        let objectChangePath\n        if (prop in target) {\n          objectChangePath = path\n        }\n\n        const mutationTree = proxifier.getMutationTree()\n        const existingValue = target[prop]\n\n\n        delete target[prop]\n\n        mutationTree.addMutation(\n          {\n            method: 'unset',\n            path: nestedPath,\n            args: [],\n            delimiter: proxifier.delimiter,\n            hasChangedValue: true,\n            revert: () => {\n              proxy[prop] = existingValue\n            },\n          },\n          objectChangePath\n        )\n\n        return true\n      },\n    })\n\n    Object.defineProperty(object, this.CACHED_PROXY, {\n      value: proxy,\n      configurable: true,\n    })\n\n    return proxy\n  }\n  proxify(value: any, path: string) {\n    if (value) {\n      const isUnmatchingProxy =\n        value[IS_PROXY] &&\n        (String(value[PATH]) !== String(path) ||\n          value[VALUE][this.CACHED_PROXY] !== value)\n\n      if (isUnmatchingProxy) {\n        return this.proxify(value[VALUE], path)\n      } else if (value[IS_PROXY]) {\n        return value\n      } else if (Array.isArray(value)) {\n        return this.createArrayProxy(value, path)\n      } else if (isPlainObject(value) || isClass(value)) {\n        return this.createObjectProxy(value, path)\n      } \n    }\n\n    return value\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}