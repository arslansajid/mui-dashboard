{"ast":null,"code":"import isPlainObject from 'is-plain-obj';\nimport { MutationTree } from './MutationTree';\nimport { IS_PROXY, PATH, PROXY_TREE, Proxifier, VALUE } from './Proxyfier';\nimport { TrackStateTree } from './TrackStateTree';\nexport { IS_PROXY, PROXY_TREE, VALUE, PATH, TrackStateTree, MutationTree };\nexport class ProxyStateTree {\n  constructor(state, options = {}) {\n    this.cache = {\n      mutationTree: [],\n      trackStateTree: []\n    };\n    this.flushCallbacks = [];\n    this.mutationCallbacks = [];\n    this.currentFlushId = 0;\n    this.pathDependencies = {};\n\n    if (!isPlainObject(state)) {\n      throw new Error('You did not pass a plain object as state to Proxy State Tree');\n    }\n\n    if (typeof options.devmode === 'undefined') {\n      options.devmode = true;\n    }\n\n    if (!options.delimiter) {\n      options.delimiter = '.';\n    }\n\n    this.master = this;\n    this.sourceState = state;\n    this.options = options;\n    this.createTrackStateProxifier();\n  }\n  /*\n    We create a base proxifier for tracking state. That means there is one\n    proxifier for all track state trees. This works because the actual tracking\n    refers to the current tree on \"master\"\n  */\n\n\n  createTrackStateProxifier() {\n    const trackStateTree = new TrackStateTree(this);\n    this.proxifier = trackStateTree.proxifier = new Proxifier(trackStateTree);\n    this.state = trackStateTree.state = this.proxifier.proxify(this.sourceState, '');\n  }\n\n  getMutationTree() {\n    if (!this.options.devmode) {\n      return this.mutationTree = this.mutationTree || new MutationTree(this, this.proxifier);\n    }\n\n    const tree = this.cache.mutationTree.pop() || new MutationTree(this);\n    return tree;\n  }\n\n  getTrackStateTree() {\n    return this.cache.trackStateTree.pop() || new TrackStateTree(this);\n  }\n\n  getTrackStateTreeWithProxifier() {\n    const tree = this.getTrackStateTree();\n    tree.proxifier = new Proxifier(tree);\n    tree.state = tree.proxifier.proxify(this.sourceState, '');\n    return tree;\n  }\n\n  changeTrackStateTree(tree) {\n    this.previousTree = this.currentTree;\n    this.currentTree = tree;\n  }\n\n  disposeTree(tree) {\n    if (tree instanceof MutationTree) {\n      this.cache.mutationTree.push(tree.dispose());\n    } else if (tree instanceof TrackStateTree) {\n      this.cache.trackStateTree.push(tree.dispose());\n    }\n  }\n\n  onMutation(callback) {\n    this.mutationCallbacks.push(callback);\n    return () => {\n      this.mutationCallbacks.splice(this.mutationCallbacks.indexOf(callback), 1);\n    };\n  }\n\n  forceFlush() {\n    const emptyMutations = [];\n    const emptyPaths = [];\n\n    for (let key in this.pathDependencies) {\n      const callbacks = this.pathDependencies[key];\n      callbacks.forEach(callback => {\n        callback(emptyMutations, emptyPaths, this.currentFlushId++, false);\n      });\n    }\n  }\n\n  flush(trees, isAsync = false) {\n    let changes;\n\n    if (Array.isArray(trees)) {\n      changes = trees.reduce((aggr, tree) => ({\n        mutations: aggr.mutations.concat(tree.getMutations()),\n        objectChanges: new Set([...aggr.objectChanges, ...tree.getObjectChanges()])\n      }), {\n        mutations: [],\n        objectChanges: new Set()\n      });\n    } else {\n      changes = {\n        mutations: trees.getMutations(),\n        objectChanges: trees.getObjectChanges()\n      };\n    }\n\n    if (!changes.mutations.length && !changes.objectChanges.size) {\n      return {\n        mutations: [],\n        flushId: null\n      };\n    }\n\n    const paths = new Set();\n    const pathCallbacksToCall = new Set();\n    const flushId = this.currentFlushId++;\n\n    for (let objectChange of changes.objectChanges) {\n      if (this.pathDependencies[objectChange]) {\n        paths.add(objectChange);\n      }\n    }\n\n    for (let mutation of changes.mutations) {\n      if (mutation.hasChangedValue) {\n        paths.add(mutation.path);\n      }\n    } // Sort so that parent paths are called first\n\n\n    const sortedPaths = Array.from(paths).sort();\n\n    for (let path of sortedPaths) {\n      if (this.pathDependencies[path]) {\n        for (let callback of this.pathDependencies[path]) {\n          pathCallbacksToCall.add(callback);\n        }\n      }\n    }\n\n    for (let callback of pathCallbacksToCall) {\n      callback(changes.mutations, sortedPaths, flushId, isAsync);\n    } // We have to ensure that we iterate all callbacks. One flush might\n    // lead to a change of the array (disposing), which means something\n    // might be skipped. But we still want to allow removal of callbacks,\n    // we just do not want to skip any, which is why we still check if it\n    // exists in the original array\n\n\n    const flushCallbacks = this.flushCallbacks.slice();\n\n    for (let callback of flushCallbacks) {\n      if (this.flushCallbacks.includes(callback)) {\n        callback(changes.mutations, sortedPaths, flushId, isAsync);\n      }\n    }\n\n    paths.clear();\n    pathCallbacksToCall.clear();\n    return {\n      mutations: changes.mutations,\n      flushId\n    };\n  }\n\n  onFlush(callback) {\n    this.flushCallbacks.push(callback);\n    return () => this.flushCallbacks.splice(this.flushCallbacks.indexOf(callback), 1);\n  }\n\n  rescope(value, tree) {\n    return value && value[IS_PROXY] ? tree.proxifier.proxify(value[VALUE], value[PATH]) : value;\n  }\n\n  addPathDependency(path, callback) {\n    if (!this.pathDependencies[path]) {\n      this.pathDependencies[path] = new Set();\n    }\n\n    this.pathDependencies[path].add(callback);\n  }\n\n  removePathDependency(path, callback) {\n    this.pathDependencies[path].delete(callback);\n\n    if (!this.pathDependencies[path].size) {\n      delete this.pathDependencies[path];\n    }\n  }\n\n  toJSON() {\n    return this.sourceState;\n  }\n\n}","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,aAAP,MAA0B,cAA1B;AAEA,SAAS,YAAT,QAA6B,gBAA7B;AACA,SAAS,QAAT,EAAmB,IAAnB,EAAyB,UAAzB,EAAqC,SAArC,EAAgD,KAAhD,QAA6D,aAA7D;AACA,SAAS,cAAT,QAA+B,kBAA/B;AAcA,SACE,QADF,EAEE,UAFF,EAGE,KAHF,EAIE,IAJF,EASE,cATF,EAUE,YAVF;AAeA,OAAM,MAAO,cAAP,CAAqB;AAmBzB,EAAA,WAAA,CAAY,KAAZ,EAAsB,OAAA,GAAoB,EAA1C,EAA4C;AAlBpC,SAAA,KAAA,GAAQ;AACd,MAAA,YAAY,EAAE,EADA;AAEd,MAAA,cAAc,EAAE;AAFF,KAAR;AAIR,SAAA,cAAA,GAAmC,EAAnC;AACA,SAAA,iBAAA,GAAyC,EAAzC;AACA,SAAA,cAAA,GAAyB,CAAzB;AAMA,SAAA,gBAAA,GAEI,EAFJ;;AAOE,QAAI,CAAC,aAAa,CAAC,KAAD,CAAlB,EAA2B;AACzB,YAAM,IAAI,KAAJ,CACJ,8DADI,CAAN;AAGD;;AAED,QAAI,OAAO,OAAO,CAAC,OAAf,KAA2B,WAA/B,EAA4C;AAC1C,MAAA,OAAO,CAAC,OAAR,GAAkB,IAAlB;AACD;;AAED,QAAI,CAAC,OAAO,CAAC,SAAb,EAAwB;AACtB,MAAA,OAAO,CAAC,SAAR,GAAoB,GAApB;AACD;;AAED,SAAK,MAAL,GAAc,IAAd;AACA,SAAK,WAAL,GAAmB,KAAnB;AACA,SAAK,OAAL,GAAe,OAAf;AAEA,SAAK,yBAAL;AACD;AACD;;;;;;;AAKQ,EAAA,yBAAyB,GAAA;AAC/B,UAAM,cAAc,GAAG,IAAI,cAAJ,CAAmB,IAAnB,CAAvB;AAEA,SAAK,SAAL,GAAiB,cAAc,CAAC,SAAf,GAA2B,IAAI,SAAJ,CAAc,cAAd,CAA5C;AACA,SAAK,KAAL,GAAa,cAAc,CAAC,KAAf,GAAuB,KAAK,SAAL,CAAe,OAAf,CAClC,KAAK,WAD6B,EAElC,EAFkC,CAApC;AAID;;AACD,EAAA,eAAe,GAAA;AACb,QAAI,CAAC,KAAK,OAAL,CAAa,OAAlB,EAA2B;AACzB,aAAQ,KAAK,YAAL,GACN,KAAK,YAAL,IAAqB,IAAI,YAAJ,CAAiB,IAAjB,EAAuB,KAAK,SAA5B,CADvB;AAED;;AAED,UAAM,IAAI,GAAG,KAAK,KAAL,CAAW,YAAX,CAAwB,GAAxB,MAAiC,IAAI,YAAJ,CAAiB,IAAjB,CAA9C;AAEA,WAAO,IAAP;AACD;;AACD,EAAA,iBAAiB,GAAA;AACf,WAAO,KAAK,KAAL,CAAW,cAAX,CAA0B,GAA1B,MAAmC,IAAI,cAAJ,CAAmB,IAAnB,CAA1C;AACD;;AACD,EAAA,8BAA8B,GAAA;AAC5B,UAAM,IAAI,GAAG,KAAK,iBAAL,EAAb;AAEA,IAAA,IAAI,CAAC,SAAL,GAAiB,IAAI,SAAJ,CAAc,IAAd,CAAjB;AACA,IAAA,IAAI,CAAC,KAAL,GAAa,IAAI,CAAC,SAAL,CAAe,OAAf,CAAuB,KAAK,WAA5B,EAAyC,EAAzC,CAAb;AAEA,WAAO,IAAP;AACD;;AACD,EAAA,oBAAoB,CAAC,IAAD,EAAyB;AAC3C,SAAK,YAAL,GAAoB,KAAK,WAAzB;AACA,SAAK,WAAL,GAAmB,IAAnB;AACD;;AACD,EAAA,WAAW,CAAC,IAAD,EAAY;AACrB,QAAI,IAAI,YAAY,YAApB,EAAkC;AAChC,WAAK,KAAL,CAAW,YAAX,CAAwB,IAAxB,CAA6B,IAAI,CAAC,OAAL,EAA7B;AACD,KAFD,MAEO,IAAI,IAAI,YAAY,cAApB,EAAoC;AACzC,WAAK,KAAL,CAAW,cAAX,CAA0B,IAA1B,CAA+B,IAAI,CAAC,OAAL,EAA/B;AACD;AACF;;AACD,EAAA,UAAU,CAAC,QAAD,EAA4B;AACpC,SAAK,iBAAL,CAAuB,IAAvB,CAA4B,QAA5B;AAEA,WAAO,MAAK;AACV,WAAK,iBAAL,CAAuB,MAAvB,CAA8B,KAAK,iBAAL,CAAuB,OAAvB,CAA+B,QAA/B,CAA9B,EAAwE,CAAxE;AACD,KAFD;AAGD;;AACD,EAAA,UAAU,GAAA;AACR,UAAM,cAAc,GAAG,EAAvB;AACA,UAAM,UAAU,GAAG,EAAnB;;AACA,SAAK,IAAI,GAAT,IAAgB,KAAK,gBAArB,EAAuC;AACrC,YAAM,SAAS,GAAG,KAAK,gBAAL,CAAsB,GAAtB,CAAlB;AACA,MAAA,SAAS,CAAC,OAAV,CAAmB,QAAD,IAAa;AAC7B,QAAA,QAAQ,CAAC,cAAD,EAAiB,UAAjB,EAA6B,KAAK,cAAL,EAA7B,EAAoD,KAApD,CAAR;AACD,OAFD;AAGD;AACF;;AACD,EAAA,KAAK,CAAC,KAAD,EAAQ,OAAA,GAAmB,KAA3B,EAAgC;AACnC,QAAI,OAAJ;;AACA,QAAI,KAAK,CAAC,OAAN,CAAc,KAAd,CAAJ,EAA0B;AACxB,MAAA,OAAO,GAAG,KAAK,CAAC,MAAN,CACR,CAAC,IAAD,EAAO,IAAP,MAAiB;AACf,QAAA,SAAS,EAAE,IAAI,CAAC,SAAL,CAAe,MAAf,CAAsB,IAAI,CAAC,YAAL,EAAtB,CADI;AAEf,QAAA,aAAa,EAAE,IAAI,GAAJ,CAAQ,CACrB,GAAG,IAAI,CAAC,aADa,EAErB,GAAG,IAAI,CAAC,gBAAL,EAFkB,CAAR;AAFA,OAAjB,CADQ,EAQR;AACE,QAAA,SAAS,EAAE,EADb;AAEE,QAAA,aAAa,EAAE,IAAI,GAAJ;AAFjB,OARQ,CAAV;AAaD,KAdD,MAcO;AACL,MAAA,OAAO,GAAG;AACR,QAAA,SAAS,EAAG,KAA4B,CAAC,YAA7B,EADJ;AAER,QAAA,aAAa,EAAG,KAA4B,CAAC,gBAA7B;AAFR,OAAV;AAID;;AAED,QAAI,CAAC,OAAO,CAAC,SAAR,CAAkB,MAAnB,IAA6B,CAAC,OAAO,CAAC,aAAR,CAAsB,IAAxD,EAA8D;AAC5D,aAAO;AACL,QAAA,SAAS,EAAE,EADN;AAEL,QAAA,OAAO,EAAE;AAFJ,OAAP;AAID;;AAED,UAAM,KAAK,GAAgB,IAAI,GAAJ,EAA3B;AACA,UAAM,mBAAmB,GAAwB,IAAI,GAAJ,EAAjD;AAEA,UAAM,OAAO,GAAG,KAAK,cAAL,EAAhB;;AAEA,SAAK,IAAI,YAAT,IAAyB,OAAO,CAAC,aAAjC,EAAgD;AAC9C,UAAI,KAAK,gBAAL,CAAsB,YAAtB,CAAJ,EAAyC;AACvC,QAAA,KAAK,CAAC,GAAN,CAAU,YAAV;AACD;AACF;;AAED,SAAK,IAAI,QAAT,IAAqB,OAAO,CAAC,SAA7B,EAAwC;AACtC,UAAI,QAAQ,CAAC,eAAb,EAA8B;AAC5B,QAAA,KAAK,CAAC,GAAN,CAAU,QAAQ,CAAC,IAAnB;AACD;AACF,KA7CkC,CA+CnC;;;AACA,UAAM,WAAW,GAAG,KAAK,CAAC,IAAN,CAAW,KAAX,EAAkB,IAAlB,EAApB;;AAEA,SAAK,IAAI,IAAT,IAAiB,WAAjB,EAA8B;AAC5B,UAAI,KAAK,gBAAL,CAAsB,IAAtB,CAAJ,EAAiC;AAC/B,aAAK,IAAI,QAAT,IAAqB,KAAK,gBAAL,CAAsB,IAAtB,CAArB,EAAkD;AAChD,UAAA,mBAAmB,CAAC,GAApB,CAAwB,QAAxB;AACD;AACF;AACF;;AAED,SAAK,IAAI,QAAT,IAAqB,mBAArB,EAA0C;AACxC,MAAA,QAAQ,CAAC,OAAO,CAAC,SAAT,EAAoB,WAApB,EAAiC,OAAjC,EAA0C,OAA1C,CAAR;AACD,KA5DkC,CA8DnC;AACA;AACA;AACA;AACA;;;AACA,UAAM,cAAc,GAAG,KAAK,cAAL,CAAoB,KAApB,EAAvB;;AACA,SAAK,IAAI,QAAT,IAAqB,cAArB,EAAqC;AACnC,UAAI,KAAK,cAAL,CAAoB,QAApB,CAA6B,QAA7B,CAAJ,EAA4C;AAC1C,QAAA,QAAQ,CAAC,OAAO,CAAC,SAAT,EAAoB,WAApB,EAAiC,OAAjC,EAA0C,OAA1C,CAAR;AACD;AACF;;AAED,IAAA,KAAK,CAAC,KAAN;AACA,IAAA,mBAAmB,CAAC,KAApB;AAEA,WAAO;AACL,MAAA,SAAS,EAAE,OAAO,CAAC,SADd;AAEL,MAAA;AAFK,KAAP;AAID;;AACD,EAAA,OAAO,CAAC,QAAD,EAAyB;AAC9B,SAAK,cAAL,CAAoB,IAApB,CAAyB,QAAzB;AAEA,WAAO,MACL,KAAK,cAAL,CAAoB,MAApB,CAA2B,KAAK,cAAL,CAAoB,OAApB,CAA4B,QAA5B,CAA3B,EAAkE,CAAlE,CADF;AAED;;AACD,EAAA,OAAO,CAAC,KAAD,EAAa,IAAb,EAAwB;AAC7B,WAAO,KAAK,IAAI,KAAK,CAAC,QAAD,CAAd,GACH,IAAI,CAAC,SAAL,CAAe,OAAf,CAAuB,KAAK,CAAC,KAAD,CAA5B,EAAqC,KAAK,CAAC,IAAD,CAA1C,CADG,GAEH,KAFJ;AAGD;;AACD,EAAA,iBAAiB,CAAC,IAAD,EAAe,QAAf,EAAuC;AACtD,QAAI,CAAC,KAAK,gBAAL,CAAsB,IAAtB,CAAL,EAAkC;AAChC,WAAK,gBAAL,CAAsB,IAAtB,IAA8B,IAAI,GAAJ,EAA9B;AACD;;AAED,SAAK,gBAAL,CAAsB,IAAtB,EAA4B,GAA5B,CAAgC,QAAhC;AACD;;AACD,EAAA,oBAAoB,CAAC,IAAD,EAAe,QAAf,EAAuC;AACzD,SAAK,gBAAL,CAAsB,IAAtB,EAA4B,MAA5B,CAAmC,QAAnC;;AAEA,QAAI,CAAC,KAAK,gBAAL,CAAsB,IAAtB,EAA4B,IAAjC,EAAuC;AACrC,aAAO,KAAK,gBAAL,CAAsB,IAAtB,CAAP;AACD;AACF;;AACD,EAAA,MAAM,GAAA;AACJ,WAAO,KAAK,WAAZ;AACD;;AApNwB","sourcesContent":["import isPlainObject from 'is-plain-obj'\n\nimport { MutationTree } from './MutationTree'\nimport { IS_PROXY, PATH, PROXY_TREE, Proxifier, VALUE } from './Proxyfier'\nimport { TrackStateTree } from './TrackStateTree'\nimport {\n  IFlushCallback,\n  IMutation,\n  IMutationCallback,\n  IMutationTree,\n  IOptions,\n  IProxifier,\n  IProxyStateTree,\n  ITrackCallback,\n  ITrackStateTree,\n  TTree,\n} from './types'\n\nexport {\n  IS_PROXY,\n  PROXY_TREE,\n  VALUE,\n  PATH,\n  IMutation,\n  ITrackCallback,\n  ITrackStateTree,\n  IMutationTree,\n  TrackStateTree,\n  MutationTree,\n}\n\nexport * from './types'\n\nexport class ProxyStateTree<T extends object> implements IProxyStateTree<T> {\n  private cache = {\n    mutationTree: [] as IMutationTree<T>[],\n    trackStateTree: [] as ITrackStateTree<T>[],\n  }\n  flushCallbacks: IFlushCallback[] = []\n  mutationCallbacks: IMutationCallback[] = []\n  currentFlushId: number = 0\n  currentTree: TTree\n  previousTree: TTree\n  mutationTree: IMutationTree<T>\n  proxifier: IProxifier<T>\n  master: ProxyStateTree<T>\n  pathDependencies: {\n    [path: string]: Set<ITrackCallback>\n  } = {}\n  state: T\n  sourceState: T\n  options: IOptions\n  constructor(state: T, options: IOptions = {}) {\n    if (!isPlainObject(state)) {\n      throw new Error(\n        'You did not pass a plain object as state to Proxy State Tree'\n      )\n    }\n\n    if (typeof options.devmode === 'undefined') {\n      options.devmode = true\n    }\n\n    if (!options.delimiter) {\n      options.delimiter = '.'\n    }\n\n    this.master = this\n    this.sourceState = state\n    this.options = options\n\n    this.createTrackStateProxifier()\n  }\n  /*\n    We create a base proxifier for tracking state. That means there is one\n    proxifier for all track state trees. This works because the actual tracking\n    refers to the current tree on \"master\"\n  */\n  private createTrackStateProxifier() {\n    const trackStateTree = new TrackStateTree(this)\n\n    this.proxifier = trackStateTree.proxifier = new Proxifier(trackStateTree)\n    this.state = trackStateTree.state = this.proxifier.proxify(\n      this.sourceState,\n      ''\n    )\n  }\n  getMutationTree(): IMutationTree<T> {\n    if (!this.options.devmode) {\n      return (this.mutationTree =\n        this.mutationTree || new MutationTree(this, this.proxifier))\n    }\n\n    const tree = this.cache.mutationTree.pop() || new MutationTree(this)\n\n    return tree\n  }\n  getTrackStateTree(): ITrackStateTree<T> {\n    return this.cache.trackStateTree.pop() || new TrackStateTree(this)\n  }\n  getTrackStateTreeWithProxifier(): ITrackStateTree<T> {\n    const tree = this.getTrackStateTree()\n\n    tree.proxifier = new Proxifier(tree)\n    tree.state = tree.proxifier.proxify(this.sourceState, '')\n\n    return tree\n  }\n  changeTrackStateTree(tree: ITrackStateTree<T>) {\n    this.previousTree = this.currentTree\n    this.currentTree = tree\n  }\n  disposeTree(tree: TTree) {\n    if (tree instanceof MutationTree) {\n      this.cache.mutationTree.push(tree.dispose())\n    } else if (tree instanceof TrackStateTree) {\n      this.cache.trackStateTree.push(tree.dispose())\n    }\n  }\n  onMutation(callback: IMutationCallback) {\n    this.mutationCallbacks.push(callback)\n\n    return () => {\n      this.mutationCallbacks.splice(this.mutationCallbacks.indexOf(callback), 1)\n    }\n  }\n  forceFlush() {\n    const emptyMutations = []\n    const emptyPaths = []\n    for (let key in this.pathDependencies) {\n      const callbacks = this.pathDependencies[key]\n      callbacks.forEach((callback) => {\n        callback(emptyMutations, emptyPaths, this.currentFlushId++, false)\n      })\n    }\n  }\n  flush(trees, isAsync: boolean = false) {\n    let changes\n    if (Array.isArray(trees)) {\n      changes = trees.reduce(\n        (aggr, tree) => ({\n          mutations: aggr.mutations.concat(tree.getMutations()),\n          objectChanges: new Set([\n            ...aggr.objectChanges,\n            ...tree.getObjectChanges(),\n          ]),\n        }),\n        {\n          mutations: [],\n          objectChanges: new Set(),\n        }\n      )\n    } else {\n      changes = {\n        mutations: (trees as IMutationTree<any>).getMutations(),\n        objectChanges: (trees as IMutationTree<any>).getObjectChanges(),\n      }\n    }\n\n    if (!changes.mutations.length && !changes.objectChanges.size) {\n      return {\n        mutations: [],\n        flushId: null,\n      }\n    }\n\n    const paths: Set<string> = new Set()\n    const pathCallbacksToCall: Set<ITrackCallback> = new Set()\n\n    const flushId = this.currentFlushId++\n\n    for (let objectChange of changes.objectChanges) {\n      if (this.pathDependencies[objectChange]) {\n        paths.add(objectChange)\n      }\n    }\n\n    for (let mutation of changes.mutations) {\n      if (mutation.hasChangedValue) {\n        paths.add(mutation.path)\n      }\n    }\n\n    // Sort so that parent paths are called first\n    const sortedPaths = Array.from(paths).sort()\n\n    for (let path of sortedPaths) {\n      if (this.pathDependencies[path]) {\n        for (let callback of this.pathDependencies[path]) {\n          pathCallbacksToCall.add(callback)\n        }\n      }\n    }\n\n    for (let callback of pathCallbacksToCall) {\n      callback(changes.mutations, sortedPaths, flushId, isAsync)\n    }\n\n    // We have to ensure that we iterate all callbacks. One flush might\n    // lead to a change of the array (disposing), which means something\n    // might be skipped. But we still want to allow removal of callbacks,\n    // we just do not want to skip any, which is why we still check if it\n    // exists in the original array\n    const flushCallbacks = this.flushCallbacks.slice()\n    for (let callback of flushCallbacks) {\n      if (this.flushCallbacks.includes(callback)) {\n        callback(changes.mutations, sortedPaths, flushId, isAsync)\n      }\n    }\n\n    paths.clear()\n    pathCallbacksToCall.clear()\n\n    return {\n      mutations: changes.mutations,\n      flushId,\n    }\n  }\n  onFlush(callback: IFlushCallback) {\n    this.flushCallbacks.push(callback)\n\n    return () =>\n      this.flushCallbacks.splice(this.flushCallbacks.indexOf(callback), 1)\n  }\n  rescope(value: any, tree: TTree) {\n    return value && value[IS_PROXY]\n      ? tree.proxifier.proxify(value[VALUE], value[PATH])\n      : value\n  }\n  addPathDependency(path: string, callback: ITrackCallback) {\n    if (!this.pathDependencies[path]) {\n      this.pathDependencies[path] = new Set()\n    }\n\n    this.pathDependencies[path].add(callback)\n  }\n  removePathDependency(path: string, callback: ITrackCallback) {\n    this.pathDependencies[path].delete(callback)\n\n    if (!this.pathDependencies[path].size) {\n      delete this.pathDependencies[path]\n    }\n  }\n  toJSON() {\n    return this.sourceState\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}