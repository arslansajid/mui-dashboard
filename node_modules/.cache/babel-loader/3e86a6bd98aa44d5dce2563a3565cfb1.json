{"ast":null,"code":"export function rehydrateState(target, source, classes = {}) {\n  if (!target || !source) {\n    throw new Error(`You have to pass a \"target\" and \"source\" object to rehydrate`);\n  }\n\n  Object.keys(source).forEach(key => {\n    const value = source[key];\n    const classInstance = classes[key];\n\n    if (typeof classInstance === 'function' && Array.isArray(target[key])) {\n      target[key] = source[key].map(value => classInstance(value));\n    } else if (typeof classInstance === 'function' && typeof target[key] === 'object' && target[key] !== null && target[key].constructor.name === 'Object') {\n      target[key] = Object.keys(source[key]).reduce((aggr, subKey) => {\n        aggr[subKey] = classInstance(source[key][subKey]);\n        return aggr;\n      }, {});\n    } else if (typeof classInstance === 'function') {\n      target[key] = classInstance(source[key]);\n    } else if (typeof value === 'object' && !Array.isArray(value) && value !== null) {\n      if (!target[key]) target[key] = {};\n      rehydrateState(target[key], source[key], classes[key]);\n    } else {\n      target[key] = source[key];\n    }\n  });\n}\nexport const SERIALIZE = Symbol('SERIALIZE');\nexport const rehydrate = (state, source, classes = {}) => {\n  if (Array.isArray(source)) {\n    const mutations = source;\n    mutations.forEach(mutation => {\n      const pathArray = mutation.path.split(mutation.delimiter);\n      const key = pathArray.pop();\n      const target = pathArray.reduce((aggr, key) => aggr[key], state);\n      const classInstance = pathArray.reduce((aggr, key) => aggr[key], classes);\n\n      if (mutation.method === 'set') {\n        if (typeof classInstance === 'function' && Array.isArray(mutation.args[0])) {\n          target[key] = mutation.args[0].map(arg => classInstance(arg));\n        } else if (typeof classInstance === 'function') {\n          target[key] = classInstance(mutation.args[0]);\n        } else {\n          target[key] = mutation.args[0];\n        }\n      } else if (mutation.method === 'unset') {\n        delete target[key];\n      } else {\n        target[key][mutation.method].apply(target[key], typeof classInstance === 'function' ? mutation.args.map(arg => {\n          return typeof arg === 'object' && arg !== null ? classInstance(arg) : arg;\n        }) : mutation.args);\n      }\n    });\n  } else {\n    rehydrateState(state, source, classes);\n  }\n};","map":{"version":3,"sources":["../src/rehydrate.ts"],"names":[],"mappings":"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","sourcesContent":["import { IMutation } from 'proxy-state-tree'\n\nexport function rehydrateState(target: any, source: any, classes: any = {}) {\n  if (!target || !source) {\n    throw new Error(`You have to pass a \"target\" and \"source\" object to rehydrate`)\n  }\n\n  Object.keys(source).forEach((key) => {\n    const value = source[key]\n    const classInstance = classes[key]\n    \n    if (typeof classInstance === 'function' && Array.isArray(target[key])) {\n      target[key] = (source[key] as any[]).map(value => classInstance(value))\n    } else if (typeof classInstance === 'function' && typeof target[key] === 'object' && target[key] !== null && target[key].constructor.name === 'Object') {\n      target[key] = Object.keys(source[key] as any).reduce((aggr, subKey) => {\n        aggr[subKey] = classInstance((source[key] as any)[subKey])\n        \n        return aggr\n      }, {})\n    } else if (typeof classInstance === 'function') {\n      target[key] = classInstance(source[key])\n    } else if (typeof value === 'object' && !Array.isArray(value) && value !== null) {\n      if (!target[key]) target[key] = {}\n      rehydrateState(target[key], source[key], classes[key])\n    } else {\n      target[key] = source[key]\n    }\n  })\n}\n\nexport const SERIALIZE = Symbol('SERIALIZE')\n\nexport interface Serialize {\n  [SERIALIZE]: boolean\n} \n\nexport type Serializable = Serialize | {\n  toJSON: () => {\n    [SERIALIZE]: boolean\n  }\n}\n\ntype SerializableValue = Serializable | Array<Serializable> | { [key: string]: Serializable } | null\n\ntype FilteredKeys<T, U> = { [P in keyof T]: T[P] extends U ? P : never }[keyof T];\n\ntype ExcludeNever<T extends {}> = { [P in keyof T]: T[P] extends never ? never : P }[keyof T]\n\ntype ExtracType<\n    T extends {},\n    K\n> = {\n    [P in FilteredKeys<T, K | {}>]:\n        T[P] extends SerializableValue ? (data: any) => Serializable :\n        T[P] extends {} ? ExtracType<T[P], K> extends { [key: string]: never } ? never : ExtractDeepType<T[P], K>  : never\n    }\n\ntype ExtractDeepType<T extends {}, K, U = ExtracType<T, K>> = {\n    [P in ExcludeNever<U>]: U[P]\n}\n\ntype StateNode = {\n  [key: string]: any\n}\n\nexport const rehydrate = <T extends StateNode>(state: T, source: IMutation[] | StateNode, classes: ExtractDeepType<T, SerializableValue> = {} as any) => {\n  if (Array.isArray(source)) {\n    const mutations = source as IMutation[]\n    mutations.forEach((mutation) => {\n      const pathArray = mutation.path.split(mutation.delimiter)\n      const key = pathArray.pop() as string\n      const target = pathArray.reduce((aggr, key) => aggr[key], state as any)\n      const classInstance = pathArray.reduce((aggr, key) => aggr[key], classes as any)\n  \n      if (mutation.method === 'set') {\n        if (typeof classInstance === 'function' && Array.isArray(mutation.args[0])) {\n          target[key] = mutation.args[0].map((arg) => classInstance(arg))\n        } else if (typeof classInstance === 'function') {\n          target[key] = classInstance(mutation.args[0])\n        } else {\n          target[key] = mutation.args[0]\n        }\n      } else if (mutation.method === 'unset') {\n        delete target[key]\n      } else {\n        target[key][mutation.method].apply(target[key], typeof classInstance === 'function' ? mutation.args.map((arg) => {\n          return typeof arg === 'object' && arg !== null ? classInstance(arg) : arg\n        }) : mutation.args)\n      }\n    })\n  } else {\n    rehydrateState(state, source, classes)\n  } \n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}