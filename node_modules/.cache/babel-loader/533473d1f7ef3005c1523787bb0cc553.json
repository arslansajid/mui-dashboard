{"ast":null,"code":"import { PROXY_TREE, VALUE } from 'proxy-state-tree';\nconst CURRENT_EXIT = Symbol('CURRENT_EXIT');\nconst INITIAL_STATE = Symbol('INITIAL_STATE');\n\nclass StateMachine {\n  constructor(definition) {\n    this[INITIAL_STATE] = definition.initial;\n    this.current = definition.initial;\n    Object.keys(definition.states).reduce((aggr, key) => {\n      aggr[key] = function (entry, exit) {\n        if (definition.states[this.current].includes(key)) {\n          const tree = this[PROXY_TREE].master.mutationTree || this[PROXY_TREE];\n          tree.enableMutations();\n          if (this[CURRENT_EXIT]) this[CURRENT_EXIT]();\n          this[VALUE][CURRENT_EXIT] = exit;\n          this.current = key;\n          const result = entry && entry();\n          tree.blockMutations();\n          return result;\n        }\n      };\n\n      return aggr;\n    }, this);\n  }\n\n  reset() {\n    const exit = this[CURRENT_EXIT];\n\n    if (typeof exit === 'function') {\n      exit();\n      this[VALUE][CURRENT_EXIT] = undefined;\n    }\n\n    this.current = this[INITIAL_STATE];\n  }\n\n}\n\nexport function statemachine(definition) {\n  return new StateMachine(definition);\n}","map":{"version":3,"sources":["../src/statemachine.ts"],"names":[],"mappings":"AAAA,SAAS,UAAT,EAAqB,KAArB,QAAkC,kBAAlC;AAgBA,MAAM,YAAY,GAAG,MAAM,CAAC,cAAD,CAA3B;AACA,MAAM,aAAa,GAAG,MAAM,CAAC,eAAD,CAA5B;;AAEA,MAAM,YAAN,CAAkB;AAIhB,EAAA,WAAA,CAAY,UAAZ,EAAsD;AACpD,SAAK,aAAL,IAAsB,UAAU,CAAC,OAAjC;AACA,SAAK,OAAL,GAAe,UAAU,CAAC,OAA1B;AAEA,IAAA,MAAM,CAAC,IAAP,CAAY,UAAU,CAAC,MAAvB,EAA+B,MAA/B,CAAsC,CAAC,IAAD,EAAO,GAAP,KAAc;AAClD,MAAA,IAAI,CAAC,GAAD,CAAJ,GAAY,UAAU,KAAV,EAAiB,IAAjB,EAAqB;AAC/B,YAAI,UAAU,CAAC,MAAX,CAAkB,KAAK,OAAvB,EAAgC,QAAhC,CAAyC,GAAzC,CAAJ,EAA0D;AACxD,gBAAM,IAAI,GAAI,KAAK,UAAL,EAAiB,MAAjB,CAAwB,YAAxB,IAAwC,KAAK,UAAL,CAAtD;AAEA,UAAA,IAAI,CAAC,eAAL;AACA,cAAI,KAAK,YAAL,CAAJ,EAAwB,KAAK,YAAL;AACxB,eAAK,KAAL,EAAY,YAAZ,IAA4B,IAA5B;AACA,eAAK,OAAL,GAAe,GAAf;AACA,gBAAM,MAAM,GAAG,KAAK,IAAI,KAAK,EAA7B;AACA,UAAA,IAAI,CAAC,cAAL;AAEA,iBAAO,MAAP;AACD;AACF,OAbD;;AAeA,aAAO,IAAP;AACD,KAjBD,EAiBG,IAjBH;AAkBD;;AACD,EAAA,KAAK,GAAA;AACH,UAAM,IAAI,GAAG,KAAK,YAAL,CAAb;;AACA,QAAI,OAAO,IAAP,KAAgB,UAApB,EAAgC;AAC9B,MAAA,IAAI;AACJ,WAAK,KAAL,EAAY,YAAZ,IAA4B,SAA5B;AACD;;AACD,SAAK,OAAL,GAAe,KAAK,aAAL,CAAf;AACD;;AAlCe;;AAqClB,OAAM,SAAU,YAAV,CAA8C,UAA9C,EAAwF;AAC5F,SAAO,IAAI,YAAJ,CAAiB,UAAjB,CAAP;AACD","sourcesContent":["import { PROXY_TREE, VALUE } from 'proxy-state-tree'\n\nexport type StatemachineDefinition<States extends string> = {\n  initial: States,\n  states: {\n    [State in States]: Array<States>\n  }\n}\n\nexport type Statemachine<States extends string> = {\n  current: States\n  reset: () => void\n} & {\n  [State in States]: <T extends () => any>(entry?: T, exit?: () => void) => T extends () => infer U ? U : void\n}\n\nconst CURRENT_EXIT = Symbol('CURRENT_EXIT')\nconst INITIAL_STATE = Symbol('INITIAL_STATE')\n\nclass StateMachine<States extends string>  {\n  current: States\n  private [CURRENT_EXIT]: (() => void) | undefined\n  private [INITIAL_STATE]: States\n  constructor(definition: StatemachineDefinition<States>) {\n    this[INITIAL_STATE] = definition.initial\n    this.current = definition.initial\n\n    Object.keys(definition.states).reduce((aggr, key) => {\n      aggr[key] = function (entry, exit) {\n        if (definition.states[this.current].includes(key as any)) {\n          const tree = (this[PROXY_TREE].master.mutationTree || this[PROXY_TREE])\n\n          tree.enableMutations()\n          if (this[CURRENT_EXIT]) this[CURRENT_EXIT]()\n          this[VALUE][CURRENT_EXIT] = exit\n          this.current = key as any\n          const result = entry && entry()\n          tree.blockMutations()\n\n          return result\n        }\n      }\n  \n      return aggr\n    }, this)\n  }\n  reset() {\n    const exit = this[CURRENT_EXIT]\n    if (typeof exit === 'function') {\n      exit()\n      this[VALUE][CURRENT_EXIT] = undefined\n    }\n    this.current = this[INITIAL_STATE]\n  }\n}\n\nexport function statemachine<States extends string>(definition: StatemachineDefinition<States>): Statemachine<States> {\n  return new StateMachine(definition) as any\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}